// Code generated by schema-generate. DO NOT EDIT.

package Usersmobcoderid170mobcodergoschemaplusschemasschemacusdecifdrepfullvthschema

import (
    "bytes"
    "encoding/json"
    "errors"
)

// APPLICATIONERRORDETAIL Code assigned by the recipient of a message to indicate a data validation error condition. 
type APPLICATIONERRORDETAIL struct {

  // Code specifying an application error.
  ApplicationErrorCode string `json:"applicationErrorCode,omitempty"`

  // Code identifying a user or association maintained code list.
  CodeListIdentificationCode string `json:"codeListIdentificationCode,omitempty"`

  // Code specifying the agency responsible for a code list.
  CodeListResponsibleAgencyCode string `json:"codeListResponsibleAgencyCode,omitempty"`
}

// APPLICATIONERRORINFORMATION  A segment identifying the type of application error or acknowledgement within the referenced message. In case of an error, the error code may specify the error in detail (e.g. a measurement relating to a piece of equipment is wrong) or as a rough indication (e.g. a measurement is wrong).
type APPLICATIONERRORINFORMATION struct {

  // Code assigned by the recipient of a message to indicate a data validation error condition. 
  ApplicationErrorDetail *APPLICATIONERRORDETAIL `json:"applicationErrorDetail,omitempty"`
}

// APPLICATIONERRORINFORMATIONItemsItems 
type APPLICATIONERRORINFORMATIONItemsItems struct {

  // Code assigned by the recipient of a message to indicate a data validation error condition. 
  ApplicationErrorDetail *APPLICATIONERRORDETAIL `json:"applicationErrorDetail,omitempty"`
}

// APPLICATIONRECIPIENTIDENTIFICATION APPLICATION RECIPIENT IDENTIFICATION.
type APPLICATIONRECIPIENTIDENTIFICATION struct {

  // Application recipient identification.
  ApplicationRecipientIdentification string `json:"applicationRecipientIdentification"`

  // Identification code qualifier.
  IdentificationCodeQualifier string `json:"identificationCodeQualifier,omitempty"`
}

// APPLICATIONSENDERIDENTIFICATION APPLICATION SENDER IDENTIFICATION.
type APPLICATIONSENDERIDENTIFICATION struct {

  // Application sender identification.
  ApplicationSenderIdentification string `json:"applicationSenderIdentification"`

  // Identification code qualifier.
  IdentificationCodeQualifier string `json:"identificationCodeQualifier,omitempty"`
}

// AcceptanceDateOfGoodsDeclarationCustoms [2036] Date on which a Goods declaration is accepted by Customs in accordance with Customs legislation.
type AcceptanceDateOfGoodsDeclarationCustoms struct {

  // Date and/or time, or period relevant to the specified date/time/period type. 
  DateTimePeriod *DATETIMEPERIOD `json:"dateTimePeriod,omitempty"`
}

// AccountingData Identifies information about accounting data.
type AccountingData struct {

  // Identification of the processing indicator. 
  ProcessingIndicator *PROCESSINGINDICATOR `json:"processingIndicator,omitempty"`

  // Code qualifying the processing information.: (2) Accounting data
  ProcessingInformationCodeQualifier string `json:"processingInformationCodeQualifier,omitempty"`
}

// AdditionalInformationItemsItems 
type AdditionalInformationItemsItems struct {

  // Code specifying the function of free text.
  FreeTextFunctionCode string `json:"freeTextFunctionCode,omitempty"`

  // Free text; one to five lines. 
  TextLiteral *TEXTLITERAL `json:"textLiteral,omitempty"`

  // Coded reference to a standard text and its source. 
  TextReference *TEXTREFERENCE `json:"textReference,omitempty"`

  // Code qualifying the subject of the text.: (ACB) Additional information
  TextSubjectCodeQualifier string `json:"textSubjectCodeQualifier,omitempty"`
}

// Adjustment Code specifying the adjustment expressed as a percentage.
type Adjustment struct {

  // Percentage relating to a specified basis. 
  PercentageDetails *PERCENTAGEDETAILS `json:"percentageDetails,omitempty"`
}

// Allowance Code specifying an allowance.
type Allowance struct {

  // Code qualifying an allowance or charge.: (A) Allowance
  AllowanceOrChargeCodeQualifier string `json:"allowanceOrChargeCodeQualifier,omitempty"`
}

// AmountDueAmountPayable Amount to be paid.
type AmountDueAmountPayable struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// AmountReferenceCurrency The owing amount in the currency used as reference in the transaction.
type AmountReferenceCurrency struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// AmountToBePaidInAdvance Amount which is to be paid before goods are delivered or the service is rendered.
type AmountToBePaidInAdvance struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// AtDestination Transport by which goods are moved at the place of destination.
type AtDestination struct {

  // Identification of a carrier by code and/or by name. Code preferred. 
  Carrier *CARRIER `json:"carrier,omitempty"`

  // To provide details of reason for, and responsibility for, use of transportation other than normally utilized. 
  ExcessTransportationInformation *EXCESSTRANSPORTATIONINFORMATION `json:"excessTransportationInformation,omitempty"`

  // To identify a journey of a means of transport.
  MeansOfTransportJourneyIdentifier string `json:"meansOfTransportJourneyIdentifier,omitempty"`

  // Method of transport code or name. Code preferred. 
  ModeOfTransport *MODEOFTRANSPORT `json:"modeOfTransport,omitempty"`

  // Code specifying the direction of transport.
  TransitDirectionIndicatorCode string `json:"transitDirectionIndicatorCode,omitempty"`

  // Code and/or name identifying the means of transport. 
  TransportIdentification *TRANSPORTIDENTIFICATION `json:"transportIdentification,omitempty"`

  // Code and/or name identifying the type of means of transport. 
  TransportMeans *TRANSPORTMEANS `json:"transportMeans,omitempty"`

  // Code qualifying a specific stage of transport.: (13) At destination
  TransportStageCodeQualifier string `json:"transportStageCodeQualifier,omitempty"`
}

// BEGINNINGOFMESSAGE  A segment identifying the type and the reference number of the message to which the CUSRES is a response.
type BEGINNINGOFMESSAGE struct {

  // Identification of a document/message by its number and eventually its version or revision. 
  DocumentMessageIdentification *DOCUMENTMESSAGEIDENTIFICATION `json:"documentMessageIdentification,omitempty"`

  // Identification of a type of document/message by code or name. Code preferred. 
  DocumentMessageName *DOCUMENTMESSAGENAME `json:"documentMessageName,omitempty"`

  // Code indicating the function of the message.: (29) Accepted without amendment; (27) Not accepted; (6) Confirmation
  MessageFunctionCode string `json:"messageFunctionCode,omitempty"`
}

// CARRIER Identification of a carrier by code and/or by name. Code preferred. 
type CARRIER struct {

  // To identify a carrier.
  CarrierIdentifier string `json:"carrierIdentifier,omitempty"`

  // Name of a carrier.
  CarrierName string `json:"carrierName,omitempty"`

  // Code identifying a user or association maintained code list.
  CodeListIdentificationCode string `json:"codeListIdentificationCode,omitempty"`

  // Code specifying the agency responsible for a code list.
  CodeListResponsibleAgencyCode string `json:"codeListResponsibleAgencyCode,omitempty"`
}

// COMMUNICATIONCONTACT Communication number of a department or employee in a specified channel. 
type COMMUNICATIONCONTACT struct {

  // Code qualifying the communication address.
  CommunicationAddressCodeQualifier string `json:"communicationAddressCodeQualifier"`

  // To identify a communication address.
  CommunicationAddressIdentifier string `json:"communicationAddressIdentifier"`
}

// COMMUNICATIONCONTACTItemsItems 
type COMMUNICATIONCONTACTItemsItems struct {

  // Communication number of a department or employee in a specified channel. 
  CommunicationContact *COMMUNICATIONCONTACT `json:"communicationContact,omitempty"`
}

// CONTACTINFORMATIONItemsItems 
type CONTACTINFORMATIONItemsItems struct {

  // Code specifying the function of a contact (e.g. department or person).
  ContactFunctionCode string `json:"contactFunctionCode,omitempty"`

  // Code and/or name of a department or employee. Code preferred. 
  DepartmentOrEmployeeDetails *DEPARTMENTOREMPLOYEEDETAILS `json:"departmentOrEmployeeDetails,omitempty"`
}

// CONTROL Control total for checking integrity of a message or part of a message. 
type CONTROL struct {

  // To specify the value of a control quantity.
  ControlTotalQuantity float64 `json:"controlTotalQuantity,omitempty"`

  // Code qualifying the type of control of hash total.: (11) Total number of packages
  ControlTotalTypeCodeQualifier string `json:"controlTotalTypeCodeQualifier,omitempty"`
}

// CONTROLTOTALItemsItems 
type CONTROLTOTALItemsItems struct {

  // Control total for checking integrity of a message or part of a message. 
  Control *CONTROL `json:"control,omitempty"`
}

// COUNTRYSUBENTITYDETAILS To specify a part of a country (eg county or part of a city). 
type COUNTRYSUBENTITYDETAILS struct {

  // Code identifying a user or association maintained code list.
  CodeListIdentificationCode string `json:"codeListIdentificationCode,omitempty"`

  // Code specifying the agency responsible for a code list.
  CodeListResponsibleAgencyCode string `json:"codeListResponsibleAgencyCode,omitempty"`

  // Name of a country sub-entity.
  CountrySubEntityName string `json:"countrySubEntityName,omitempty"`

  // Code specifying the name of a country sub-entity.
  CountrySubEntityNameCode string `json:"countrySubEntityNameCode,omitempty"`
}

// CURRENCIES  A segment identifying currencies and the rate of exchange for a monetary amount identified within this group.
type CURRENCIES struct {

  // The usage to which a currency relates. 
  CurrencyDetails1 *CURRENCYDETAILS `json:"currencyDetails_1,omitempty"`

  // The usage to which a currency relates. 
  CurrencyDetails2 *CURRENCYDETAILS `json:"currencyDetails_2,omitempty"`

  // To specify the rate at which one specified currency is expressed in another specified currency.
  CurrencyExchangeRate float64 `json:"currencyExchangeRate,omitempty"`
}

// CURRENCYDETAILS The usage to which a currency relates. 
type CURRENCYDETAILS struct {

  // Code specifying a monetary unit.
  CurrencyIdentificationCode string `json:"currencyIdentificationCode,omitempty"`

  // To specify the value of the multiplication factor used in expressing currency units.
  CurrencyRate float64 `json:"currencyRate,omitempty"`

  // Code qualifying the type of currency.
  CurrencyTypeCodeQualifier string `json:"currencyTypeCodeQualifier,omitempty"`

  // Code qualifying the usage of a currency.
  CurrencyUsageCodeQualifier string `json:"currencyUsageCodeQualifier"`
}

// CUSTOMSIDENTITYCODES Specification of goods in terms of customs identity. 
type CUSTOMSIDENTITYCODES struct {

  // Code identifying the goods for customs.
  CustomsGoodsIdentifier string `json:"customsGoodsIdentifier,omitempty"`
}

// CUSTOMSSTATUSOFGOODS  A segment identifying goods in terms of customs identities, status and intended use.
type CUSTOMSSTATUSOFGOODS struct {

  // To specify a goods item within a consignment.
  GoodsItemNumber float64 `json:"goodsItemNumber"`
}

// Consignee (3132) Party to which goods are consigned.
type Consignee struct {

  // Name of a city.
  CityName string `json:"cityName,omitempty"`

  // Identification of the name of the country or other geographical entity as defined in ISO 3166-1.
  CountryNameCode string `json:"countryNameCode,omitempty"`

  // To specify a part of a country (eg county or part of a city). 
  CountrySubEntityDetails *COUNTRYSUBENTITYDETAILS `json:"countrySubEntityDetails,omitempty"`

  // Unstructured name and address: one to five lines. 
  NameAndAddress *NAMEANDADDRESS `json:"nameAndAddress,omitempty"`

  // Code giving specific meaning to a party.: (CN) Consignee
  PartyFunctionCodeQualifier string `json:"partyFunctionCodeQualifier,omitempty"`

  // Identification of a transaction party by code. 
  PartyIdentificationDetails *PARTYIDENTIFICATIONDETAILS `json:"partyIdentificationDetails,omitempty"`

  // Identification of a transaction party by name, one to five lines. Party name may be formatted. 
  PartyName *PARTYNAME `json:"partyName,omitempty"`

  // Code specifying the postal zone or address.
  PostalIdentificationCode string `json:"postalIdentificationCode,omitempty"`

  // Street address and/or PO Box number in a structured address: one to four lines. 
  Street *STREET `json:"street,omitempty"`
}

// ConsignmentTypeInformation Identifies information about the consignment type.
type ConsignmentTypeInformation struct {

  // Identification of the processing indicator. 
  ProcessingIndicator *PROCESSINGINDICATOR `json:"processingIndicator,omitempty"`

  // Code qualifying the processing information.: (5) Consignment type information
  ProcessingInformationCodeQualifier string `json:"processingInformationCodeQualifier,omitempty"`
}

// Consignor (3336) Party which, by contract with a carrier, consigns or sends goods with the carrier, or has them conveyed by him. Synonym: shipper, sender.
type Consignor struct {

  // Name of a city.
  CityName string `json:"cityName"`

  // Identification of the name of the country or other geographical entity as defined in ISO 3166-1.
  CountryNameCode string `json:"countryNameCode"`

  // To specify a part of a country (eg county or part of a city). 
  CountrySubEntityDetails *COUNTRYSUBENTITYDETAILS `json:"countrySubEntityDetails,omitempty"`

  // Unstructured name and address: one to five lines. 
  NameAndAddress *NAMEANDADDRESS `json:"nameAndAddress,omitempty"`

  // Code giving specific meaning to a party.: (CZ) Consignor
  PartyFunctionCodeQualifier string `json:"partyFunctionCodeQualifier,omitempty"`

  // Identification of a transaction party by code. 
  PartyIdentificationDetails *PARTYIDENTIFICATIONDETAILS `json:"partyIdentificationDetails,omitempty"`

  // Identification of a transaction party by name, one to five lines. Party name may be formatted. 
  PartyName *PARTYNAME `json:"partyName,omitempty"`

  // Code specifying the postal zone or address.
  PostalIdentificationCode string `json:"postalIdentificationCode"`

  // Street address and/or PO Box number in a structured address: one to four lines. 
  Street *STREET `json:"street,omitempty"`
}

// CountryOfExportationDespatch (3220) Country from which the goods were initially exported to the importing country without any commercial transaction taking place in intermediate countries. Syn.: country whence consigned. Country of despatch: country from which goods are despatched between countries of a Customs union.
type CountryOfExportationDespatch struct {

  // Code identifying the function of a location.: (35) Country of exportation/despatch
  LocationFunctionCodeQualifier string `json:"locationFunctionCodeQualifier,omitempty"`

  // Identification of a location by code or name. 
  LocationIdentification *LOCATIONIDENTIFICATION `json:"locationIdentification,omitempty"`
}

// CountryOfOrigin [3238] Country in which the goods have been produced or manufactured, according to criteria laid down for the purposes of application of the Customs tariff, of quantitative restrictions, or of any other measure related to trade.
type CountryOfOrigin struct {

  // Code identifying the function of a location.: (27) Country of origin
  LocationFunctionCodeQualifier string `json:"locationFunctionCodeQualifier,omitempty"`

  // Identification of a location by code or name. 
  LocationIdentification *LOCATIONIDENTIFICATION `json:"locationIdentification,omitempty"`
}

// CountryOfTransitItemsItems 
type CountryOfTransitItemsItems struct {

  // Code identifying the function of a location.: (49) Country of transit
  LocationFunctionCodeQualifier string `json:"locationFunctionCodeQualifier,omitempty"`

  // Identification of a location by code or name. 
  LocationIdentification *LOCATIONIDENTIFICATION `json:"locationIdentification,omitempty"`
}

// Customs Identification of customs authority relevant to the transaction or shipment.
type Customs struct {

  // Name of a city.
  CityName string `json:"cityName,omitempty"`

  // Identification of the name of the country or other geographical entity as defined in ISO 3166-1.
  CountryNameCode string `json:"countryNameCode,omitempty"`

  // To specify a part of a country (eg county or part of a city). 
  CountrySubEntityDetails *COUNTRYSUBENTITYDETAILS `json:"countrySubEntityDetails,omitempty"`

  // Unstructured name and address: one to five lines. 
  NameAndAddress *NAMEANDADDRESS `json:"nameAndAddress,omitempty"`

  // Code giving specific meaning to a party.: (CM) Customs
  PartyFunctionCodeQualifier string `json:"partyFunctionCodeQualifier,omitempty"`

  // Identification of a transaction party by code. 
  PartyIdentificationDetails *PARTYIDENTIFICATIONDETAILS `json:"partyIdentificationDetails,omitempty"`

  // Identification of a transaction party by name, one to five lines. Party name may be formatted. 
  PartyName *PARTYNAME `json:"partyName,omitempty"`

  // Code specifying the postal zone or address.
  PostalIdentificationCode string `json:"postalIdentificationCode,omitempty"`

  // Street address and/or PO Box number in a structured address: one to four lines. 
  Street *STREET `json:"street,omitempty"`
}

// CustomsDeclarationInformation Note contains customs declaration information.
type CustomsDeclarationInformation struct {

  // Code specifying the function of free text.
  FreeTextFunctionCode string `json:"freeTextFunctionCode,omitempty"`

  // Free text; one to five lines. 
  TextLiteral *TEXTLITERAL `json:"textLiteral,omitempty"`

  // Coded reference to a standard text and its source. 
  TextReference *TEXTREFERENCE `json:"textReference,omitempty"`

  // Code qualifying the subject of the text.: (CUS) Customs declaration information
  TextSubjectCodeQualifier string `json:"textSubjectCodeQualifier,omitempty"`
}

// CustomsDeclarationNumber [1426] Number, assigned or accepted by Customs, to identify a Goods declaration.
type CustomsDeclarationNumber struct {

  // Identification of a reference. 
  Reference *REFERENCE `json:"reference,omitempty"`
}

// CustomsDuty Duties laid down in the Customs tariff to which goods are liable on entering or leaving the Customs territory (CCC).
type CustomsDuty struct {

  // Code qualifying the function of a duty or tax or fee.: (5) Customs duty
  DutyOrTaxOrFeeFunctionCodeQualifier string `json:"dutyOrTaxOrFeeFunctionCodeQualifier,omitempty"`
}

// CustomsOfficeOfClearance (3080) Place where Customs clearance procedure occur (CCC).
type CustomsOfficeOfClearance struct {

  // Code identifying the function of a location.: (22) Customs office of clearance
  LocationFunctionCodeQualifier string `json:"locationFunctionCodeQualifier,omitempty"`

  // Identification of a location by code or name. 
  LocationIdentification *LOCATIONIDENTIFICATION `json:"locationIdentification,omitempty"`

  // Identification the first related location by code or name. 
  RelatedLocationOneIdentification *RELATEDLOCATIONONEIDENTIFICATION `json:"relatedLocationOneIdentification,omitempty"`
}

// CustomsReleaseCode A code associated to a requirement that must be presented to gain the release of goods by Customs.
type CustomsReleaseCode struct {

  // Identification of a reference. 
  Reference *REFERENCE `json:"reference,omitempty"`
}

// CustomsValue [5032] Value declared for Customs purposes on those goods in a consignment which are subject to the same Customs procedure, and have the same tariff/statistical heading, country information and duty regime.
type CustomsValue struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// DATAELEMENTIDENTIFICATION DATA ELEMENT IDENTIFICATION.
type DATAELEMENTIDENTIFICATION struct {

  // Erroneous component data element position.
  ErroneousComponentDataElementPosition float64 `json:"erroneousComponentDataElementPosition,omitempty"`

  // Erroneous data element occurrence.
  ErroneousDataElementOccurrence float64 `json:"erroneousDataElementOccurrence,omitempty"`

  // Erroneous data element position in segment.
  ErroneousDataElementPositionInSegment float64 `json:"erroneousDataElementPositionInSegment"`
}

// DATETIMEPERIOD Date and/or time, or period relevant to the specified date/time/period type. 
type DATETIMEPERIOD struct {

  // Code specifying the representation of a date, time or period.: (203) CCYYMMDDHHMM
  DateOrTimeOrPeriodFormatCode string `json:"dateOrTimeOrPeriodFormatCode,omitempty"`

  // Code qualifying the function of a date, time or period.: (148) Acceptance date of Goods declaration (Customs)
  DateOrTimeOrPeriodFunctionCodeQualifier string `json:"dateOrTimeOrPeriodFunctionCodeQualifier,omitempty"`

  // The value of a date, a date and time, a time or of a period in a specified representation.
  DateOrTimeOrPeriodText string `json:"dateOrTimeOrPeriodText,omitempty"`
}

// DATETIMEPERIODItemsItems 
type DATETIMEPERIODItemsItems struct {

  // Date and/or time, or period relevant to the specified date/time/period type. 
  DateTimePeriod *DATETIMEPERIOD `json:"dateTimePeriod,omitempty"`
}

// DEPARTMENTOREMPLOYEEDETAILS Code and/or name of a department or employee. Code preferred. 
type DEPARTMENTOREMPLOYEEDETAILS struct {

  // Name of a department or employee.
  DepartmentOrEmployeeName string `json:"departmentOrEmployeeName,omitempty"`

  // Code specifying the name of a department or employee.
  DepartmentOrEmployeeNameCode string `json:"departmentOrEmployeeNameCode,omitempty"`
}

// DOCUMENTMESSAGEDETAILS Identification of document/message by number, status, source and/or language. 
type DOCUMENTMESSAGEDETAILS struct {

  // To identify a document.
  DocumentIdentifier string `json:"documentIdentifier,omitempty"`
}

// DOCUMENTMESSAGEIDENTIFICATION Identification of a document/message by its number and eventually its version or revision. 
type DOCUMENTMESSAGEIDENTIFICATION struct {

  // To identify a document.
  DocumentIdentifier string `json:"documentIdentifier,omitempty"`

  // To identify a revision.
  RevisionIdentifier string `json:"revisionIdentifier,omitempty"`

  // To identify a version.
  VersionIdentifier string `json:"versionIdentifier,omitempty"`
}

// DOCUMENTMESSAGENAME Identification of a type of document/message by code or name. Code preferred. 
type DOCUMENTMESSAGENAME struct {

  // Code identifying a user or association maintained code list.
  CodeListIdentificationCode string `json:"codeListIdentificationCode,omitempty"`

  // Code specifying the agency responsible for a code list.: (109) GB, H.M. Customs & Excise
  CodeListResponsibleAgencyCode string `json:"codeListResponsibleAgencyCode,omitempty"`

  // Name of a document.
  DocumentName string `json:"documentName,omitempty"`

  // Code specifying the document name.
  DocumentNameCode string `json:"documentNameCode,omitempty"`
}

// DOCUMENTMESSAGESUMMARY  A segment identifying the commercial document number, the document type and the number of detail lines within the document heading this group.
type DOCUMENTMESSAGESUMMARY struct {

  // Identification of a document/message by its number and eventually its version or revision. 
  DocumentMessageIdentification *DOCUMENTMESSAGEIDENTIFICATION `json:"documentMessageIdentification,omitempty"`
}

// DUTYTAXFEEACCOUNTDETAIL Indication of account reference for duties, taxes and/or fees. 
type DUTYTAXFEEACCOUNTDETAIL struct {

  // Code specifying a duty or tax or fee account.
  DutyOrTaxOrFeeAccountCode string `json:"dutyOrTaxOrFeeAccountCode,omitempty"`
}

// DUTYTAXFEEDETAIL Rate of duty/tax/fee applicable to commodities or of tax applicable to services. 
type DUTYTAXFEEDETAIL struct {

  // Code identifying a user or association maintained code list.
  CodeListIdentificationCode1 string `json:"codeListIdentificationCode_1,omitempty"`

  // Code identifying a user or association maintained code list.
  CodeListIdentificationCode2 string `json:"codeListIdentificationCode_2,omitempty"`

  // Code specifying the agency responsible for a code list.
  CodeListResponsibleAgencyCode1 string `json:"codeListResponsibleAgencyCode_1,omitempty"`

  // Code specifying the agency responsible for a code list.: (109) GB, H.M. Customs & Excise
  CodeListResponsibleAgencyCode2 string `json:"codeListResponsibleAgencyCode_2,omitempty"`

  // Rate of a duty or tax or fee.
  DutyOrTaxOrFeeRate string `json:"dutyOrTaxOrFeeRate,omitempty"`

  // Code specifying the basis for a duty or tax or fee rate.
  DutyOrTaxOrFeeRateBasisCode string `json:"dutyOrTaxOrFeeRateBasisCode,omitempty"`

  // Code specifying a rate of a duty or tax or fee.
  DutyOrTaxOrFeeRateCode string `json:"dutyOrTaxOrFeeRateCode,omitempty"`
}

// DUTYTAXFEETYPE Code and/or name identifying duty, tax or fee. 
type DUTYTAXFEETYPE struct {

  // Code specifying a type of duty, tax or fee.
  DutyOrTaxOrFeeTypeNameCode string `json:"dutyOrTaxOrFeeTypeNameCode"`
}

// DataElementErrorIndicationItemsItems 
type DataElementErrorIndicationItemsItems struct {

  // DATA ELEMENT IDENTIFICATION.
  DataElementIdentification *DATAELEMENTIDENTIFICATION `json:"dataElementIdentification,omitempty"`

  // Syntax error, coded.
  SyntaxErrorCoded string `json:"syntaxErrorCoded"`
}

// DataElementErrorIndicationsItemsItems 
type DataElementErrorIndicationsItemsItems struct {

  // DATA ELEMENT IDENTIFICATION.
  DataElementIdentification *DATAELEMENTIDENTIFICATION `json:"dataElementIdentification,omitempty"`

  // Syntax error, coded.
  SyntaxErrorCoded string `json:"syntaxErrorCoded"`
}

// DateAndTimeOfPreparation Date and time of preparation of the interchange.
type DateAndTimeOfPreparation struct {

  // Date the interchange was prepared.
  DateOfPreparation string `json:"dateOfPreparation,omitempty"`

  // Time the interchange was prepared.
  TimeOfPreparation string `json:"timeOfPreparation,omitempty"`
}

// Declarant (3140) Party who makes a declaration to an official body or - where legally permitted - in whose name, or on whose behalf, a declaration to an official body is made.
type Declarant struct {

  // Name of a city.
  CityName string `json:"cityName,omitempty"`

  // Identification of the name of the country or other geographical entity as defined in ISO 3166-1.
  CountryNameCode string `json:"countryNameCode,omitempty"`

  // To specify a part of a country (eg county or part of a city). 
  CountrySubEntityDetails *COUNTRYSUBENTITYDETAILS `json:"countrySubEntityDetails,omitempty"`

  // Unstructured name and address: one to five lines. 
  NameAndAddress *NAMEANDADDRESS `json:"nameAndAddress,omitempty"`

  // Code giving specific meaning to a party.: (DT) Declarant
  PartyFunctionCodeQualifier string `json:"partyFunctionCodeQualifier,omitempty"`

  // Identification of a transaction party by code. 
  PartyIdentificationDetails *PARTYIDENTIFICATIONDETAILS `json:"partyIdentificationDetails,omitempty"`

  // Identification of a transaction party by name, one to five lines. Party name may be formatted. 
  PartyName *PARTYNAME `json:"partyName,omitempty"`

  // Code specifying the postal zone or address.
  PostalIdentificationCode string `json:"postalIdentificationCode,omitempty"`

  // Street address and/or PO Box number in a structured address: one to four lines. 
  Street *STREET `json:"street,omitempty"`
}

// DefermentApprovalNumber Number assigned by authorities to a party to approve deferment of payment of tax or duties.
type DefermentApprovalNumber struct {

  // Identification of a reference. 
  Reference *REFERENCE `json:"reference,omitempty"`
}

// DeferredPaymentReference [1168] Reference or indication of the deferred payment or guarantee of duty/tax.
type DeferredPaymentReference struct {

  // Identification of a reference. 
  Reference *REFERENCE `json:"reference,omitempty"`
}

// DetailSummarySectionSeparation To qualify the segment UNS, when separating the detail from the summary section of a message.
type DetailSummarySectionSeparation struct {

  // Identification of the separation of sections of a message.: (S) Detail/summary section separation
  SectionIdentification string `json:"sectionIdentification,omitempty"`
}

// DimensionsTotalWeight The total weight of an identified dimension.
type DimensionsTotalWeight struct {

  // Identification of measurement type. 
  MeasurementDetails *MEASUREMENTDETAILS `json:"measurementDetails,omitempty"`

  // Code qualifying the purpose of the measurement.: (AAH) Dimensions total weight
  MeasurementPurposeCodeQualifier string `json:"measurementPurposeCodeQualifier,omitempty"`

  // Measurement value and relevant minimum and maximum values of the measurement range. 
  ValueRange *VALUERANGE `json:"valueRange,omitempty"`
}

// Discount Discount expressed as a percentage.
type Discount struct {

  // Percentage relating to a specified basis. 
  PercentageDetails *PERCENTAGEDETAILS `json:"percentageDetails,omitempty"`
}

// DiscountAmount (5014) The amount specified is the discount amount.
type DiscountAmount struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// DutyAmount The amount of duty.
type DutyAmount struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// DutyTaxFeeBasisAmount The amount specified is the basis for duty/tax or fee.
type DutyTaxFeeBasisAmount struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// DutyTaxOrFeeAmount Amount of duty, tax or fee.
type DutyTaxOrFeeAmount struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// ERRORPOINTDETAILS  A segment identifying the location of an application error within the referenced message.
type ERRORPOINTDETAILS struct {

  // Indication of the point of error in a message. 
  ErrorPointDetails *ERRORPOINTDETAILS `json:"errorPointDetails,omitempty"`

  // To indicate the exact segment location of an application error within a message. 
  ErrorSegmentPointDetails *ERRORSEGMENTPOINTDETAILS `json:"errorSegmentPointDetails,omitempty"`
}

// ERRORSEGMENTPOINTDETAILS To indicate the exact segment location of an application error within a message. 
type ERRORSEGMENTPOINTDETAILS struct {

  // To identify the tag of a segment.
  SegmentTagIdentifier string `json:"segmentTagIdentifier,omitempty"`

  // Code specifying the source of a sequence identifier.
  SequenceIdentifierSourceCode float64 `json:"sequenceIdentifierSourceCode,omitempty"`

  // To identify a position in a sequence.
  SequencePositionIdentifier float64 `json:"sequencePositionIdentifier,omitempty"`
}

// EXCESSTRANSPORTATIONINFORMATION To provide details of reason for, and responsibility for, use of transportation other than normally utilized. 
type EXCESSTRANSPORTATIONINFORMATION struct {

  // To identify the authorisation to ship issued by the customer.
  CustomerShipmentAuthorisationIdentifier string `json:"customerShipmentAuthorisationIdentifier,omitempty"`

  // Code specifying the reason for excess transportation.
  ExcessTransportationReasonCode string `json:"excessTransportationReasonCode"`

  // Code specifying the responsibility for excess transportation.
  ExcessTransportationResponsibilityCode string `json:"excessTransportationResponsibilityCode"`
}

// EffectiveFromDateTime (2069) Date and/or time at which specified event or document becomes effective.
type EffectiveFromDateTime struct {

  // Date and/or time, or period relevant to the specified date/time/period type. 
  DateTimePeriod *DATETIMEPERIOD `json:"dateTimePeriod,omitempty"`
}

// FREETEXT  A segment to provide explanation and/or supplementary information related to the specified application error or acknowledgement. For example, the explanation may provide exact details relating to a generic error code.
type FREETEXT struct {

  // Code specifying the format of free text.
  FreeTextFormatCode string `json:"freeTextFormatCode,omitempty"`

  // Code specifying the function of free text.
  FreeTextFunctionCode string `json:"freeTextFunctionCode,omitempty"`

  // Code specifying the language name.
  LanguageNameCode string `json:"languageNameCode,omitempty"`

  // Free text; one to five lines. 
  TextLiteral *TEXTLITERAL `json:"textLiteral,omitempty"`

  // Coded reference to a standard text and its source. 
  TextReference *TEXTREFERENCE `json:"textReference,omitempty"`

  // Code qualifying the subject of the text.
  TextSubjectCodeQualifier string `json:"textSubjectCodeQualifier"`
}

// FREETEXTItemsItems 
type FREETEXTItemsItems struct {

  // Code specifying the format of free text.
  FreeTextFormatCode string `json:"freeTextFormatCode,omitempty"`

  // Code specifying the function of free text.
  FreeTextFunctionCode string `json:"freeTextFunctionCode,omitempty"`

  // Code specifying the language name.
  LanguageNameCode string `json:"languageNameCode,omitempty"`

  // Free text; one to five lines. 
  TextLiteral *TEXTLITERAL `json:"textLiteral,omitempty"`

  // Coded reference to a standard text and its source. 
  TextReference *TEXTREFERENCE `json:"textReference,omitempty"`

  // Code qualifying the subject of the text.
  TextSubjectCodeQualifier string `json:"textSubjectCodeQualifier,omitempty"`
}

// FreightCharge Amount to be paid for moving goods, by whatever means, from one place to another, inclusive discounts, allowances, rebates, adjustment factors and additional cost relating to freight costs (UN/ECE Recommendation no 23).
type FreightCharge struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// GRP1 GRP1 -  A group of segments identifying various references, manifest quantities and package identities relevant to the whole message.
type GRP1 struct {

  // A unique reference assigned by the originator.
  OriginatorsReference *OriginatorSReference `json:"originatorsReference,omitempty"`
}

// GRP10 GRP10 -  A group of segments identifying currencies, a rate of exchange and an associated date related to the monetary amount.
type GRP10 struct {

  //  A segment identifying currencies and the rate of exchange for a monetary amount identified within this group.
  Currencies *CURRENCIES `json:"currencies,omitempty"`
}

// GRP11 GRP11 -  A group of segments identifying various monetary amounts, currencies and rates of exchange that pertain to the whole commercial document.
type GRP11 struct {

  // Amount to be paid for moving goods, by whatever means, from one place to another, inclusive discounts, allowances, rebates, adjustment factors and additional cost relating to freight costs (UN/ECE Recommendation no 23).
  FreightCharge *FreightCharge `json:"freightCharge,omitempty"`

  // [5488] Amount of premium payable to the insurance company to insure the goods to the port or place of importation.
  InsuranceChargesCustoms *InsuranceChargesCustoms `json:"insuranceChargesCustoms,omitempty"`

  // [5444] Total sum charged in respect of one or more Invoices in accordance with the terms of delivery.
  InvoiceTotalAmount *InvoiceTotalAmount `json:"invoiceTotalAmount"`

  // Other charges deducted from the total invoice value.
  OtherDeductibleCharges *OtherDeductibleCharges `json:"otherDeductibleCharges,omitempty"`

  // Other valuation charges which are payable by reason of the importation or sale of the goods in the Customs territory.
  OtherValuationChargesCustoms *OtherValuationChargesCustoms `json:"otherValuationChargesCustoms,omitempty"`

  // (5292) Cost incurred by shipper in moving goods, by whatever means, from one place to another under the terms of the contract of carriage, see UN/ECE Recommendation No 23. Synonym: freight charges (Customs).
  TransportChargesCustoms *TransportChargesCustoms `json:"transportChargesCustoms,omitempty"`
}

// GRP11Items 
type GRP11Items struct {

  // Amount of duty, tax or fee.
  DutyTaxOrFeeAmount *DutyTaxOrFeeAmount `json:"dutyTaxOrFeeAmount"`

  // Total of each duty, tax or fee charged on the goods declaration (CCC).
  TotalOfEachDutyTaxOrFeeTypeCustomsDeclaration *TotalOfEachDutyTaxOrFeeTypeCustomsDeclaration `json:"totalOfEachDutyTaxOrFeeTypeCustomsDeclaration,omitempty"`
}

// GRP12Items 
type GRP12Items struct {

  //  A segment identifying goods in terms of customs identities, status and intended use.
  CustomsStatusOfGoods *CUSTOMSSTATUSOFGOODS `json:"customsStatusOfGoods,omitempty"`

  // GRP13 -  A group of segments identifying the customs amounts for- duties, taxes and fees related to the customs items identified in CST.
  DutyTaxAndFeeTotal *GRP13 `json:"dutyTaxAndFeeTotal,omitempty"`

  // GRP13 -  A group of segments identifying the customs amounts for- duties, taxes and fees related to the customs items identified in CST.
  IndividualDutyTaxOrFeeItems []*GRP13Items `json:"individualDutyTaxOrFeeItems,omitempty"`
}

// GRP13 GRP13 -  A group of segments identifying the customs amounts for- duties, taxes and fees related to the customs items identified in CST.
type GRP13 struct {

  // Duties laid down in the Customs tariff to which goods are liable on entering or leaving the Customs territory (CCC).
  CustomsDuty *CustomsDuty `json:"customsDuty,omitempty"`

  // [5032] Value declared for Customs purposes on those goods in a consignment which are subject to the same Customs procedure, and have the same tariff/statistical heading, country information and duty regime.
  CustomsValue *CustomsValue `json:"customsValue,omitempty"`

  // The amount of duty.
  DutyAmount *DutyAmount `json:"dutyAmount,omitempty"`

  // (5068) Total sum charged in respect of a single Invoice item in accordance with the terms of delivery.
  InvoiceItemAmount *InvoiceItemAmount `json:"invoiceItemAmount,omitempty"`

  // Amount in the currency of the licence to be written off from the total licence value.
  LicenceValueDeducted *LicenceValueDeducted `json:"licenceValueDeducted,omitempty"`

  // [5490] Amount in national currency resulting from the application, at the appropriate rate, of value added tax (or similar tax) to the invoice amount subject to such tax.
  ValueAddedTax *ValueAddedTax `json:"valueAddedTax,omitempty"`

  // First VAT value if, for the same rate of VAT, there are 1 to 3 different ways to set this value.
  Vat1stValue *VAT1stValue `json:"vat1stValue,omitempty"`
}

// GRP13Items 
type GRP13Items struct {

  // Amount of duty, tax or fee.
  DutyTaxOrFeeAmount *DutyTaxOrFeeAmount `json:"dutyTaxOrFeeAmount,omitempty"`

  // Individual duty, tax or fee charged on a single Customs item line of the goods declaration (CCC).
  IndividualDutyTaxOrFeeCustomsItem *IndividualDutyTaxOrFeeCustomsItem `json:"individualDutyTaxOrFeeCustomsItem,omitempty"`
}

// GRP19 GRP19 -  A group of segments identifying allowances, charges, or adjustments and related details for the whole commercial document.
type GRP19 struct {

  // Code specifying an allowance.
  Allowance *Allowance `json:"allowance,omitempty"`

  // Discount expressed as a percentage.
  Discount *Discount `json:"discount,omitempty"`

  // (5014) The amount specified is the discount amount.
  DiscountAmount *DiscountAmount `json:"discountAmount,omitempty"`
}

// GRP1Items 
type GRP1Items struct {

  // Items:  A segment to provide explanation and/or supplementary information related to the specified application error.
  FreeTextItems []*FREETEXTItemsItems `json:"freeTextItems,omitempty"`

  // Message Level Action and Error Codes.
  MessageLevelActionAndErrorCodes *MessageLevelActionAndErrorCodes `json:"messageLevelActionAndErrorCodes,omitempty"`

  // Message/package response.
  MessagePackageResponse *MessagePackageResponse `json:"messagePackageResponse,omitempty"`

  // GRP2 - Segment Group 2.
  ResponseDetailItems []*GRP2Items `json:"responseDetailItems,omitempty"`
}

// GRP2Items 
type GRP2Items struct {

  // Items: Data element error indications.
  DataElementErrorIndicationsItems []*DataElementErrorIndicationsItemsItems `json:"dataElementErrorIndicationsItems,omitempty"`

  // Segment error indication.
  SegmentErrorIndication *SegmentErrorIndication `json:"segmentErrorIndication,omitempty"`
}

// GRP3 GRP3 -  A group of segments identifying references, dates and locations related information.
type GRP3 struct {

  // (1202) Unique reference of a consignment (UCRN) used for identification purposes in documents and messages exchanged between parties in international trade. See also: Unique Identifier Code (UNIC) in UN/ECE Recommendation No. 8, March 1992.
  UniqueConsignmentReferenceNumber *UniqueConsignmentReferenceNumber `json:"uniqueConsignmentReferenceNumber,omitempty"`
}

// GRP30Items 
type GRP30Items struct {

  // GRP40 -  A group of segments identifying special indicators or value data related to the customs item.
  AccountingDataAdjustmentCode *GRP40 `json:"accountingDataAdjustmentCode,omitempty"`

  // GRP40 -  A group of segments identifying special indicators or value data related to the customs item.
  AccountingDataMethodCode *GRP40 `json:"accountingDataMethodCode,omitempty"`

  // Items: The text contains additional information.
  AdditionalInformationItems []*AdditionalInformationItemsItems `json:"additionalInformationItems,omitempty"`

  // (3132) Party to which goods are consigned.
  Consignee *Consignee `json:"consignee,omitempty"`

  // (3336) Party which, by contract with a carrier, consigns or sends goods with the carrier, or has them conveyed by him. Synonym: shipper, sender.
  Consignor *Consignor `json:"consignor,omitempty"`

  // [3238] Country in which the goods have been produced or manufactured, according to criteria laid down for the purposes of application of the Customs tariff, of quantitative restrictions, or of any other measure related to trade.
  CountryOfOrigin *CountryOfOrigin `json:"countryOfOrigin,omitempty"`

  // Items: Country through which goods transit.
  CountryOfTransitItems []*CountryOfTransitItemsItems `json:"countryOfTransitItems,omitempty"`

  // Identification of customs authority relevant to the transaction or shipment.
  Customs *Customs `json:"customs,omitempty"`

  //  A segment identifying the customs tariff of the goods, their required treatment and, where these are different to the header information, the type of declaration and the current status of the goods.
  CustomsStatusOfGoods *CUSTOMSSTATUSOFGOODS `json:"customsStatusOfGoods,omitempty"`

  // The total weight of an identified dimension.
  DimensionsTotalWeight *DimensionsTotalWeight `json:"dimensionsTotalWeight,omitempty"`

  // GRP31 -  A group of segments identifying the number, type and reference of the packing units associated with the customs item.
  Grp31 []*GRP31Items `json:"grp31,omitempty"`

  // GRP33 -  A group of segments identifying various monetary amounts, currencies and rates of exchange that pertain to the customs item.
  Grp33 *GRP33 `json:"grp33,omitempty"`

  // GRP41 -  A group of segments identifying duties/taxes/fees and methods of payment related to a customs item.
  Grp41 []*GRP41Items `json:"grp41,omitempty"`

  // Primary reportable quantity associated with a tariff number.
  I1stSpecifiedTariffQuantity *_1stSpecifiedTariffQuantity `json:"i1stSpecifiedTariffQuantity,omitempty"`

  // Secondary reportable quantity associated with a tariff number.
  I2ndSpecifiedTariffQuantity *_2ndSpecifiedTariffQuantity `json:"i2ndSpecifiedTariffQuantity,omitempty"`

  // Third reportable quantity associated with a tariff number.
  I3rdSpecifiedTariffQuantity *_3rdSpecifiedTariffQuantity `json:"i3rdSpecifiedTariffQuantity,omitempty"`

  // GRP35 -  A group of segments identifying references, descriptions, and monetary amounts associated with a customs item.
  ItemDetailsAndReference *GRP35 `json:"itemDetailsAndReference"`

  // GRP40 -  A group of segments identifying special indicators or value data related to the customs item.
  OtherAccountingCodes []*GRP40Items `json:"otherAccountingCodes,omitempty"`

  // GRP37 -  A group of segments identifying report documentary requirements of particular government agencies, with the optional name and address of the agency involved.
  PreviousCustomsDocuments []*GRP37Items `json:"previousCustomsDocuments,omitempty"`

  // GRP35 -  A group of segments identifying references, descriptions, and monetary amounts associated with a customs item.
  QuotaNumber *GRP35 `json:"quotaNumber,omitempty"`

  // GRP37 -  A group of segments identifying report documentary requirements of particular government agencies, with the optional name and address of the agency involved.
  RelatedDocuments []*GRP37Items `json:"relatedDocuments,omitempty"`

  // GRP35 -  A group of segments identifying references, descriptions, and monetary amounts associated with a customs item.
  UnitLoadDeviceEGContainerIdentificationNumberItems []*GRP35Items `json:"unitLoadDeviceEGContainerIdentificationNumberItems,omitempty"`

  // GRP35 -  A group of segments identifying references, descriptions, and monetary amounts associated with a customs item.
  UnitedNationsDangerousGoodsUndgNumber *GRP35 `json:"unitedNationsDangerousGoodsUndgNumber,omitempty"`
}

// GRP31Items 
type GRP31Items struct {

  // GRP32 -  A group of segments identifying marks and labels, and giving the description of single packages associated with a customs item.
  Grp32 *GRP32 `json:"grp32,omitempty"`

  //  A segment identifying the number and type of packages relating to the customs item.
  Package *PACKAGE `json:"package,omitempty"`
}

// GRP32 GRP32 -  A group of segments identifying marks and labels, and giving the description of single packages associated with a customs item.
type GRP32 struct {

  //  A segment identifying markings and labels on the type of packages reported in the preceding PAC.
  PackageIdentification *PACKAGEIDENTIFICATION `json:"packageIdentification,omitempty"`
}

// GRP33 GRP33 -  A group of segments identifying various monetary amounts, currencies and rates of exchange that pertain to the customs item.
type GRP33 struct {

  // (5068) Total sum charged in respect of a single Invoice item in accordance with the terms of delivery.
  InvoiceItemAmount *InvoiceItemAmount `json:"invoiceItemAmount,omitempty"`

  // [5218] Value declared for statistical purposes of those goods in a consignment which have the same statistical heading and country of origin.
  StatisticalValue *StatisticalValue `json:"statisticalValue,omitempty"`
}

// GRP35 GRP35 -  A group of segments identifying references, descriptions, and monetary amounts associated with a customs item.
type GRP35 struct {

  // [7124] Unique serial number assigned within the United Nations to substances and articles contained in a list of the dangerous goods most commonly carried.
  UnitedNationsDangerousGoodsUndgNumber *UnitedNationsDangerousGoodsUNDGNumber `json:"unitedNationsDangerousGoodsUndgNumber,omitempty"`
}

// GRP35Items 
type GRP35Items struct {

  // [8260] Marks (letters and/or numbers) which identify a unit load device e.g. freight container.
  UnitLoadDeviceEGContainerIdentificationNumber *UnitLoadDeviceEGContainerIdentificationNumber `json:"unitLoadDeviceEGContainerIdentificationNumber,omitempty"`
}

// GRP36 GRP36 -  A group of segments identifying a commercial description for a documented commodity that is associated with this customs line item.
type GRP36 struct {

  //  A segment identifying the coded industry description of the merchandise on the document line(s) identified in the preceding GIN segment.
  ItemDescription *ITEMDESCRIPTION `json:"itemDescription"`
}

// GRP37Items 
type GRP37Items struct {

  // Indication of the previous Customs document/message concerning the same transaction.
  PreviousCustomsDocumentMessage *PreviousCustomsDocumentMessage `json:"previousCustomsDocumentMessage,omitempty"`
}

// GRP3Items 
type GRP3Items struct {

  // Group responses.
  GroupResponses *GroupResponses `json:"groupResponses,omitempty"`

  // GRP4 - Segment Group 4.
  MessageResponses []*GRP4Items `json:"messageResponses,omitempty"`
}

// GRP4 GRP4 -  A group of segments identifying the mode, means and identification of the transport used.
type GRP4 struct {

  // Transport by which goods are moved at the place of destination.
  AtDestination *AtDestination `json:"atDestination"`

  // Transport by which goods are moved from or to the frontier, or between inland points.
  InlandTransport *InlandTransport `json:"inlandTransport,omitempty"`
}

// GRP40 GRP40 -  A group of segments identifying special indicators or value data related to the customs item.
type GRP40 struct {

  // Identifies information about accounting data.
  AccountingData *AccountingData `json:"accountingData,omitempty"`
}

// GRP40Items 
type GRP40Items struct {

  // Identifies information about the consignment type.
  ConsignmentTypeInformation *ConsignmentTypeInformation `json:"consignmentTypeInformation,omitempty"`
}

// GRP41Items 
type GRP41Items struct {

  // The amount specified is the basis for duty/tax or fee.
  DutyTaxFeeBasisAmount *DutyTaxFeeBasisAmount `json:"dutyTaxFeeBasisAmount,omitempty"`

  // Amount of duty, tax or fee.
  DutyTaxOrFeeAmount *DutyTaxOrFeeAmount `json:"dutyTaxOrFeeAmount,omitempty"`

  // Individual duty, tax or fee charged on a single Customs item line of the goods declaration (CCC).
  IndividualDutyTaxOrFeeCustomsItem *IndividualDutyTaxOrFeeCustomsItem `json:"individualDutyTaxOrFeeCustomsItem,omitempty"`
}

// GRP4Items 
type GRP4Items struct {

  // Items:  A segment identifying the type of application errors within a message.
  ApplicationErrorInformationItems []*APPLICATIONERRORINFORMATIONItemsItems `json:"applicationErrorInformationItems,omitempty"`

  //  A segment identifying the location of an application error within the referenced message.
  ErrorPointDetails *ERRORPOINTDETAILS `json:"errorPointDetails,omitempty"`

  // Items:  A segment to provide explanation and/or supplementary information related to the specified application error.
  FreeTextItems []*FREETEXTItemsItems `json:"freeTextItems,omitempty"`

  // Items:  A segment to provide the references related to the application error.
  ReferenceItems []*REFERENCEItemsItems `json:"referenceItems,omitempty"`
}

// GRP5Items 
type GRP5Items struct {

  // A code assigned within a code list to be used on an interim basis and as defined among trading partners until a precise code can be assigned to the code list.
  MutuallyDefined *MutuallyDefined `json:"mutuallyDefined,omitempty"`

  // Document that has a relationship with the stated document/message.
  RelatedDocument *RelatedDocument `json:"relatedDocument,omitempty"`
}

// GRP6 GRP6 -  A group of segments specifying goods item details including status of goods, related references, package identification, details of transport, relevant parties, contacts, dates and/or times and location, general indicators, measurements, documentary requirements, monetary amounts, currencies and item taxes, fees and duties.
type GRP6 struct {

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  AmountDueAmountPayable *GRP9 `json:"amountDueAmountPayable,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  AmountReferenceCurrency *GRP9 `json:"amountReferenceCurrency,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  AmountToBePaidInAdvance *GRP9 `json:"amountToBePaidInAdvance,omitempty"`

  // GRP11 -  A group of segments identifying customs amounts for taxes, duties and fees related to a single customs declaration (e.g. a simplified customs declaration).
  CustomsAndDutiesPerDeclarationItems []*GRP11Items `json:"customsAndDutiesPerDeclarationItems,omitempty"`

  // GRP12 -  A group of segments identifying goods in terms of customs identities and customs amounts for duties, taxes and fees, following computation by customs.
  CustomsAndDutiesPerItemItems []*GRP12Items `json:"customsAndDutiesPerItemItems,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  CustomsValue *GRP9 `json:"customsValue,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  DiscountAmount *GRP9 `json:"discountAmount,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  DutyAmount *GRP9 `json:"dutyAmount,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  FreightCharge *GRP9 `json:"freightCharge,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  InsuranceChargesCustoms *GRP9 `json:"insuranceChargesCustoms,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  InvoiceTotalAmount *GRP9 `json:"invoiceTotalAmount,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  MessageTotalDutyTaxFeeAmount *GRP9 `json:"messageTotalDutyTaxFeeAmount,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  OtherDeductibleCharges *GRP9 `json:"otherDeductibleCharges,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  OtherValuationChargesCustoms *GRP9 `json:"otherValuationChargesCustoms,omitempty"`

  // A set of documents, replacing the various (national) forms for Customs declaration within the EC, implemented on 01-01-1988.
  SingleAdministrativeDocument *SingleAdministrativeDocument `json:"singleAdministrativeDocument,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  TransportChargesCustoms *GRP9 `json:"transportChargesCustoms,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  ValueAddedTax *GRP9 `json:"valueAddedTax,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  Vat1stValue *GRP9 `json:"vat1stValue,omitempty"`
}

// GRP7 GRP7 -  A group of segments identifying the terms of delivery pertinent to the entire message.
type GRP7 struct {

  //  A segment identifying terms of delivery, relevant to the entire message, in a coded format.
  TermsOfDeliveryOrTransport *TERMSOFDELIVERYORTRANSPORT `json:"termsOfDeliveryOrTransport,omitempty"`
}

// GRP9 GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
type GRP9 struct {

  // GRP10 -  A group of segments identifying currencies, a rate of exchange and an associated date related to the monetary amount.
  Grp10 *GRP10 `json:"grp10,omitempty"`

  //  A segment identifying the monetary amount.
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// GoodsDeclarationNumber Reference number assigned to a goods declaration.
type GoodsDeclarationNumber struct {

  // Identification of a reference. 
  Reference *REFERENCE `json:"reference,omitempty"`
}

// GroupResponses Group responses.
type GroupResponses struct {

  // Action coded.
  ActionCoded string `json:"actionCoded"`

  // APPLICATION RECIPIENT IDENTIFICATION.
  ApplicationRecipientIdentification *APPLICATIONRECIPIENTIDENTIFICATION `json:"applicationRecipientIdentification,omitempty"`

  // APPLICATION SENDER IDENTIFICATION.
  ApplicationSenderIdentification *APPLICATIONSENDERIDENTIFICATION `json:"applicationSenderIdentification,omitempty"`

  // DATA ELEMENT IDENTIFICATION.
  DataElementIdentification *DATAELEMENTIDENTIFICATION `json:"dataElementIdentification,omitempty"`

  // Group reference number.
  GroupReferenceNumber float64 `json:"groupReferenceNumber"`

  // Security reference number.
  SecurityReferenceNumber string `json:"securityReferenceNumber,omitempty"`

  // Security segment position.
  SecuritySegmentPosition string `json:"securitySegmentPosition,omitempty"`

  // Service segment tag, coded.
  ServiceSegmentTagCoded string `json:"serviceSegmentTagCoded,omitempty"`

  // Syntax error coded.
  SyntaxErrorCoded string `json:"syntaxErrorCoded,omitempty"`
}

// HeaderDetailSectionSeparation To qualify the segment UNS, when separating the header from the detail section of a message.
type HeaderDetailSectionSeparation struct {

  // Identification of the separation of sections of a message.: (D) Header/detail section separation
  SectionIdentification string `json:"sectionIdentification,omitempty"`
}

// INTERCHANGERECIPIENT INTERCHANGE RECIPIENT.
type INTERCHANGERECIPIENT struct {

  // Code identifying a user or association maintained code list.
  IdentificationCodeQualifier string `json:"identificationCodeQualifier,omitempty"`

  // Interchange recipient identification.
  InterchangeRecipientIdentification string `json:"interchangeRecipientIdentification"`

  // Interchange recipient internal identification.
  InterchangeRecipientInternalIdentification string `json:"interchangeRecipientInternalIdentification,omitempty"`

  // Interchange recipient internal sub-identification.
  InterchangeRecipientInternalSubIdentification string `json:"interchangeRecipientInternalSubIdentification,omitempty"`
}

// INTERCHANGESENDER INTERCHANGE SENDER.
type INTERCHANGESENDER struct {

  // Code identifying a user or association maintained code list.
  IdentificationCodeQualifier string `json:"identificationCodeQualifier,omitempty"`

  // Interchange sender identification.
  InterchangeSenderIdentification string `json:"interchangeSenderIdentification"`

  // Interchange sender internal identification.
  InterchangeSenderInternalIdentification string `json:"interchangeSenderInternalIdentification,omitempty"`

  // Interchange sender internal sub-identification.
  InterchangeSenderInternalSubIdentification string `json:"interchangeSenderInternalSubIdentification,omitempty"`
}

// ITEMCHARACTERISTIC To provide the characteristic of the item being described. 
type ITEMCHARACTERISTIC struct {

  // Code identifying a user or association maintained code list.
  CodeListIdentificationCode string `json:"codeListIdentificationCode,omitempty"`

  // Code specifying the agency responsible for a code list.
  CodeListResponsibleAgencyCode string `json:"codeListResponsibleAgencyCode,omitempty"`

  // Code specifying the characteristic of an item.
  ItemCharacteristicCode string `json:"itemCharacteristicCode,omitempty"`
}

// ITEMDESCRIPTION  A segment identifying the coded industry description of the merchandise on the document line(s) identified in the preceding GIN segment.
type ITEMDESCRIPTION struct {

  // Code specifying the format of a description.
  DescriptionFormatCode string `json:"descriptionFormatCode,omitempty"`

  // To provide the characteristic of the item being described. 
  ItemCharacteristic *ITEMCHARACTERISTIC `json:"itemCharacteristic,omitempty"`

  // Description of an item. 
  ItemDescription *ITEMDESCRIPTION `json:"itemDescription,omitempty"`
}

// ImportClearanceInstructionReferenceNumber Reference number of the import clearance instructions given by the consignor/consignee through different means.
type ImportClearanceInstructionReferenceNumber struct {

  // Identification of a reference. 
  Reference *REFERENCE `json:"reference,omitempty"`
}

// IndividualDutyTaxOrFeeCustomsItem Individual duty, tax or fee charged on a single Customs item line of the goods declaration (CCC).
type IndividualDutyTaxOrFeeCustomsItem struct {

  // To specify the basis on which a duty or tax or fee will be assessed.
  DutyOrTaxOrFeeAssessmentBasisQuantity string `json:"dutyOrTaxOrFeeAssessmentBasisQuantity,omitempty"`

  // Code qualifying the function of a duty or tax or fee.: (1) Individual duty, tax or fee (Customs item)
  DutyOrTaxOrFeeFunctionCodeQualifier string `json:"dutyOrTaxOrFeeFunctionCodeQualifier,omitempty"`

  // Indication of account reference for duties, taxes and/or fees. 
  DutyTaxFeeAccountDetail *DUTYTAXFEEACCOUNTDETAIL `json:"dutyTaxFeeAccountDetail,omitempty"`

  // Rate of duty/tax/fee applicable to commodities or of tax applicable to services. 
  DutyTaxFeeDetail *DUTYTAXFEEDETAIL `json:"dutyTaxFeeDetail,omitempty"`

  // Code and/or name identifying duty, tax or fee. 
  DutyTaxFeeType *DUTYTAXFEETYPE `json:"dutyTaxFeeType,omitempty"`
}

// InlandTransport Transport by which goods are moved from or to the frontier, or between inland points.
type InlandTransport struct {

  // To identify a journey of a means of transport.
  MeansOfTransportJourneyIdentifier string `json:"meansOfTransportJourneyIdentifier,omitempty"`

  // Method of transport code or name. Code preferred. 
  ModeOfTransport *MODEOFTRANSPORT `json:"modeOfTransport,omitempty"`

  // Code qualifying a specific stage of transport.: (1) Inland transport
  TransportStageCodeQualifier string `json:"transportStageCodeQualifier,omitempty"`
}

// InsuranceChargesCustoms [5488] Amount of premium payable to the insurance company to insure the goods to the port or place of importation.
type InsuranceChargesCustoms struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// InterchangeHeader Interchange Header Segment
type InterchangeHeader struct {

  // Date and time of preparation of the interchange.
  DateAndTimeOfPreparation *DateAndTimeOfPreparation `json:"dateAndTimeOfPreparation,omitempty"`

  // Unique reference assigned by the sender to an interchange.
  InterchangeControlReference string `json:"interchangeControlReference,omitempty"`

  // Identification of the Recipient of the interchange.
  InterchangeRecipient *InterchangeRecipient `json:"interchangeRecipient,omitempty"`

  // Identification of the sender of the interchange.
  InterchangeSender *InterchangeSender `json:"interchangeSender,omitempty"`

  // Identification of the agency controlling the syntax and indication of syntax level.
  Syntax *SYNTAX `json:"syntax,omitempty"`
}

// InterchangeRecipient Identification of the Recipient of the interchange.
type InterchangeRecipient struct {

  // Address for reverse routing.
  AddressForReverseRouting string `json:"addressForReverseRouting,omitempty"`

  // Version number of the syntax identified in the syntax identifier (0001).
  PartnerIdentificationCodeQualifier string `json:"partnerIdentificationCodeQualifier,omitempty"`

  // Name or coded representation of the recipient of a data interchange.
  RecipientIdentification string `json:"recipientIdentification,omitempty"`
}

// InterchangeResponse To identify the subject interchange, to indicate interchange receipt, to indicate acknowledgement or rejection (action taken) of the UNA, UNB and UNZ segments, and to identify any error related to these segments. It can also identify errors related to the USA, USC, USD, USH, USR, UST, or USU security segments when they appear at the interchange level. Depending on the action code, it may also indicate the action taken on the groups, messages, and packages within that interchange.
type InterchangeResponse struct {

  // Action coded.
  ActionCoded string `json:"actionCoded,omitempty"`

  // DATA ELEMENT IDENTIFICATION.
  DataElementIdentification *DATAELEMENTIDENTIFICATION `json:"dataElementIdentification,omitempty"`

  // Interchange control reference.
  InterchangeControlReference string `json:"interchangeControlReference"`

  // INTERCHANGE RECIPIENT.
  InterchangeRecipient *INTERCHANGERECIPIENT `json:"interchangeRecipient,omitempty"`

  // INTERCHANGE SENDER.
  InterchangeSender *INTERCHANGESENDER `json:"interchangeSender,omitempty"`

  // Security reference number.
  SecurityReferenceNumber string `json:"securityReferenceNumber,omitempty"`

  // Security segment position.
  SecuritySegmentPosition string `json:"securitySegmentPosition,omitempty"`

  // Service segment tag, coded.
  ServiceSegmentTagCoded string `json:"serviceSegmentTagCoded,omitempty"`

  // Syntax error coded.
  SyntaxErrorCoded string `json:"syntaxErrorCoded,omitempty"`
}

// InterchangeSender Identification of the sender of the interchange.
type InterchangeSender struct {

  // Address for reverse routing.
  AddressForReverseRouting string `json:"addressForReverseRouting,omitempty"`

  // Version number of the syntax identified in the syntax identifier (0001).
  PartnerIdentificationCodeQualifier string `json:"partnerIdentificationCodeQualifier,omitempty"`

  // Name or coded representation of the sender of a data interchange.
  SenderIdentification string `json:"senderIdentification,omitempty"`
}

// InterchangeTrailer Close of the Interchange message.
type InterchangeTrailer struct {

  // Count either of the number of messages or, if used, of the number of functional groups in an interchange.
  InterchangeControlCount float64 `json:"interchangeControlCount,omitempty"`

  // Unique reference assigned by the sender to an interchange.
  InterchangeControlReference string `json:"interchangeControlReference,omitempty"`
}

// InvoiceItemAmount (5068) Total sum charged in respect of a single Invoice item in accordance with the terms of delivery.
type InvoiceItemAmount struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// InvoiceTotalAmount [5444] Total sum charged in respect of one or more Invoices in accordance with the terms of delivery.
type InvoiceTotalAmount struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// LOCATIONIDENTIFICATION Identification of a location by code or name. 
type LOCATIONIDENTIFICATION struct {

  // Code identifying a user or association maintained code list.
  CodeListIdentificationCode string `json:"codeListIdentificationCode,omitempty"`

  // Code specifying the agency responsible for a code list.: (109) GB, H.M. Customs & Excise
  CodeListResponsibleAgencyCode string `json:"codeListResponsibleAgencyCode,omitempty"`

  // Code specifying the name of the location.
  LocationNameCode string `json:"locationNameCode"`
}

// LicenceValueDeducted Amount in the currency of the licence to be written off from the total licence value.
type LicenceValueDeducted struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// LocationOfGoods [3384] Place where goods are located.
type LocationOfGoods struct {

  // Code identifying the function of a location.: (14) Location of goods
  LocationFunctionCodeQualifier string `json:"locationFunctionCodeQualifier,omitempty"`

  // Identification of a location by code or name. 
  LocationIdentification *LOCATIONIDENTIFICATION `json:"locationIdentification,omitempty"`
}

// MARKSLABELS Shipping marks on packages in free text; one to ten lines. 
type MARKSLABELS struct {

  // Free form description of the shipping marks.
  ShippingMarksDescription1 string `json:"shippingMarksDescription_1,omitempty"`

  // Free form description of the shipping marks.
  ShippingMarksDescription2 string `json:"shippingMarksDescription_2,omitempty"`
}

// MEASUREMENTDETAILS Identification of measurement type. 
type MEASUREMENTDETAILS struct {

  // Code specifying the attribute measured.
  MeasuredAttributeCode string `json:"measuredAttributeCode,omitempty"`

  // Code specifying the significance of a measurement.
  MeasurementSignificanceCode string `json:"measurementSignificanceCode,omitempty"`

  // Name of a non-discrete measurement.
  NonDiscreteMeasurementName string `json:"nonDiscreteMeasurementName,omitempty"`

  // Code specifying the name of a non-discrete measurement.
  NonDiscreteMeasurementNameCode string `json:"nonDiscreteMeasurementNameCode,omitempty"`
}

// MESSAGEHEADER  A service segment starting and uniquely identifying a message. The message type code for the Customs response message is CUSRES.
type MESSAGEHEADER struct {

  // Reference serving as a key to relate all subsequent transfers of data to the same business case or file.
  CommonAccessReference string `json:"commonAccessReference,omitempty"`

  // Identification of the type, version, etc. of the message being interchanged. 
  MessageIdentifier *MESSAGEIDENTIFIER `json:"messageIdentifier,omitempty"`

  // Unique message reference assigned by the sender.
  MessageReferenceNumber string `json:"messageReferenceNumber,omitempty"`
}

// MESSAGEIDENTIFIER Identification of the type, version, etc. of the message being interchanged. 
type MESSAGEIDENTIFIER struct {

  // Code, assigned by the association responsible for the design and maintenance of the message type concerned, which further identifies the message.
  AssociationAssignedCode string `json:"associationAssignedCode,omitempty"`

  // Code identifying a controlling agency.: (UN) UN/CEFACT
  ControllingAgencyCoded string `json:"controllingAgencyCoded,omitempty"`

  // Release number within the current message version number.: 
  MessageReleaseNumber string `json:"messageReleaseNumber,omitempty"`

  // Code identifying a type of message and assigned by its controlling agency.: (CUSRES) Customs response message
  MessageType string `json:"messageType,omitempty"`

  // Version number of a message type.: (D) Draft version/UN/EDIFACT Directory
  MessageVersionNumber string `json:"messageVersionNumber,omitempty"`
}

// MESSAGEIMPLEMENTATIONGUIDELINEIDENTIFICATION Identification of a message implementation guideline by its identifier, version, release and source. 
type MESSAGEIMPLEMENTATIONGUIDELINEIDENTIFICATION struct {

  // Code identifying a controlling agency.
  ControllingAgencyCoded string `json:"controllingAgencyCoded,omitempty"`

  // Coded identification of the message implementation guideline, assigned by its controlling agency.
  MessageImplementationGuidelineIdentification string `json:"messageImplementationGuidelineIdentification"`

  // Release number within the message implementation guideline version number.
  MessageImplementationGuidelineReleaseNumber string `json:"messageImplementationGuidelineReleaseNumber,omitempty"`

  // Version number of the message implementation guideline.
  MessageImplementationGuidelineVersionNumber string `json:"messageImplementationGuidelineVersionNumber,omitempty"`
}

// MESSAGESUBSETIDENTIFICATION Identification of a message subset by its identifier, version, release and source. 
type MESSAGESUBSETIDENTIFICATION struct {

  // Code identifying a controlling agency.
  ControllingAgencyCoded string `json:"controllingAgencyCoded,omitempty"`

  // Coded identification of a message subset, assigned by its controlling agency.
  MessageSubsetIdentification string `json:"messageSubsetIdentification"`

  // Release number within the message subset version number.
  MessageSubsetReleaseNumber string `json:"messageSubsetReleaseNumber,omitempty"`

  // Version number of the message subset.
  MessageSubsetVersionNumber string `json:"messageSubsetVersionNumber,omitempty"`
}

// MESSAGETRAILER  A service segment ending a message, giving the total number of segments in the message (including the UNH & UNT) and the control reference number of the message.
type MESSAGETRAILER struct {

  // Unique message reference assigned by the sender.
  MessageReferenceNumber string `json:"messageReferenceNumber,omitempty"`

  // The number of segments in a message body, plus the message header segment and message trailer segment.
  NumberOfSegmentsInAMessage float64 `json:"numberOfSegmentsInAMessage,omitempty"`
}

// MODEOFTRANSPORT Method of transport code or name. Code preferred. 
type MODEOFTRANSPORT struct {

  // Code specifying the name of a mode of transport.
  TransportModeNameCode string `json:"transportModeNameCode,omitempty"`
}

// MONETARYAMOUNT  A segment identifying the monetary amount.
type MONETARYAMOUNT struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// MessageLevelActionAndErrorCodes Message Level Action and Error Codes.
type MessageLevelActionAndErrorCodes struct {

  // Action coded.
  ActionCoded string `json:"actionCoded"`

  // Syntax error coded.
  SyntaxErrorCoded string `json:"syntaxErrorCoded,omitempty"`
}

// MessagePackageResponse Message/package response.
type MessagePackageResponse struct {

  // Action coded.
  ActionCoded string `json:"actionCoded,omitempty"`

  // DATA ELEMENT IDENTIFICATION.
  DataElementIdentification *DATAELEMENTIDENTIFICATION `json:"dataElementIdentification,omitempty"`

  // Identification of the type, version, etc. of the message being interchanged. 
  MessageIdentifier *MESSAGEIDENTIFIER `json:"messageIdentifier,omitempty"`

  // Unique message reference assigned by the sender.
  MessageReferenceNumber string `json:"messageReferenceNumber"`

  // Package reference number.
  PackageReferenceNumber string `json:"packageReferenceNumber,omitempty"`

  // REFERENCE IDENTIFICATION.
  ReferenceIdentification *REFERENCEIDENTIFICATION `json:"referenceIdentification,omitempty"`

  // Security reference number.
  SecurityReferenceNumber string `json:"securityReferenceNumber,omitempty"`

  // Security segment position.
  SecuritySegmentPosition string `json:"securitySegmentPosition,omitempty"`

  // Service segment tag, coded.
  ServiceSegmentTagCoded string `json:"serviceSegmentTagCoded,omitempty"`

  // Syntax error coded.
  SyntaxErrorCoded string `json:"syntaxErrorCoded,omitempty"`
}

// MessageTotalDutyTaxFeeAmount Total of all duty/tax/fee amounts.
type MessageTotalDutyTaxFeeAmount struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// MutuallyDefined A code assigned within a code list to be used on an interim basis and as defined among trading partners until a precise code can be assigned to the code list.
type MutuallyDefined struct {

  // Date and/or time, or period relevant to the specified date/time/period type. 
  DateTimePeriod *DATETIMEPERIOD `json:"dateTimePeriod,omitempty"`
}

// MutuallyDefinedReferenceNumber Number based on party agreement.
type MutuallyDefinedReferenceNumber struct {

  // Identification of a reference. 
  Reference *REFERENCE `json:"reference,omitempty"`
}

// NAMEANDADDRESS Unstructured name and address: one to five lines. 
type NAMEANDADDRESS struct {

  // Free form description of a name and address line.
  NameAndAddressDescription1 string `json:"nameAndAddressDescription_1"`

  // Free form description of a name and address line.
  NameAndAddressDescription2 string `json:"nameAndAddressDescription_2,omitempty"`

  // Free form description of a name and address line.
  NameAndAddressDescription3 string `json:"nameAndAddressDescription_3,omitempty"`

  // Free form description of a name and address line.
  NameAndAddressDescription4 string `json:"nameAndAddressDescription_4,omitempty"`

  // Free form description of a name and address line.
  NameAndAddressDescription5 string `json:"nameAndAddressDescription_5,omitempty"`
}

// NotifyParty (3180) Party to be notified of arrival of goods.
type NotifyParty struct {

  // Name of a city.
  CityName string `json:"cityName,omitempty"`

  // Identification of the name of the country or other geographical entity as defined in ISO 3166-1.
  CountryNameCode string `json:"countryNameCode,omitempty"`

  // To specify a part of a country (eg county or part of a city). 
  CountrySubEntityDetails *COUNTRYSUBENTITYDETAILS `json:"countrySubEntityDetails,omitempty"`

  // Unstructured name and address: one to five lines. 
  NameAndAddress *NAMEANDADDRESS `json:"nameAndAddress,omitempty"`

  // Code giving specific meaning to a party.: (NI) Notify party
  PartyFunctionCodeQualifier string `json:"partyFunctionCodeQualifier,omitempty"`

  // Identification of a transaction party by code. 
  PartyIdentificationDetails *PARTYIDENTIFICATIONDETAILS `json:"partyIdentificationDetails,omitempty"`

  // Identification of a transaction party by name, one to five lines. Party name may be formatted. 
  PartyName *PARTYNAME `json:"partyName,omitempty"`

  // Code specifying the postal zone or address.
  PostalIdentificationCode string `json:"postalIdentificationCode,omitempty"`

  // Street address and/or PO Box number in a structured address: one to four lines. 
  Street *STREET `json:"street,omitempty"`
}

// OriginalPortOfLoading The port where the goods were first loaded on a vessel.
type OriginalPortOfLoading struct {

  // Code identifying the function of a location.: (76) Original port of loading
  LocationFunctionCodeQualifier string `json:"locationFunctionCodeQualifier,omitempty"`

  // Identification of a location by code or name. 
  LocationIdentification *LOCATIONIDENTIFICATION `json:"locationIdentification,omitempty"`
}

// OriginatorSReference A unique reference assigned by the originator.
type OriginatorSReference struct {

  // Identification of a reference. 
  Reference *REFERENCE `json:"reference,omitempty"`
}

// OtherDeductibleCharges Other charges deducted from the total invoice value.
type OtherDeductibleCharges struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// OtherValuationChargesCustoms Other valuation charges which are payable by reason of the importation or sale of the goods in the Customs territory.
type OtherValuationChargesCustoms struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// PACKAGE  A segment identifying the number and type of packages relating to the customs item.
type PACKAGE struct {

  // To specify the number of packages.
  PackageQuantity float64 `json:"packageQuantity,omitempty"`

  // Type of package by name or by code from a specified source. 
  PackageType *PACKAGETYPE `json:"packageType,omitempty"`

  // Packaging level and details, terms and conditions. 
  PackagingDetails *PACKAGINGDETAILS `json:"packagingDetails,omitempty"`
}

// PACKAGEIDENTIFICATION  A segment identifying markings and labels on the type of packages reported in the preceding PAC.
type PACKAGEIDENTIFICATION struct {

  // Code specifying instructions for marking.
  MarkingInstructionsCode string `json:"markingInstructionsCode,omitempty"`

  // Shipping marks on packages in free text; one to ten lines. 
  MarksLabels *MARKSLABELS `json:"marksLabels,omitempty"`
}

// PACKAGETYPE Type of package by name or by code from a specified source. 
type PACKAGETYPE struct {

  // Code specifying the type of package.
  PackageTypeDescriptionCode string `json:"packageTypeDescriptionCode"`
}

// PACKAGINGDETAILS Packaging level and details, terms and conditions. 
type PACKAGINGDETAILS struct {

  // Code specifying a level of packaging.
  PackagingLevelCode string `json:"packagingLevelCode,omitempty"`

  // Code specifying information related to packaging.
  PackagingRelatedDescriptionCode string `json:"packagingRelatedDescriptionCode,omitempty"`

  // Code specifying the packaging terms and conditions.
  PackagingTermsAndConditionsCode string `json:"packagingTermsAndConditionsCode,omitempty"`
}

// PARTYIDENTIFICATIONDETAILS Identification of a transaction party by code. 
type PARTYIDENTIFICATIONDETAILS struct {

  // Code identifying a user or association maintained code list.
  CodeListIdentificationCode string `json:"codeListIdentificationCode,omitempty"`

  // Code specifying the agency responsible for a code list.
  CodeListResponsibleAgencyCode string `json:"codeListResponsibleAgencyCode,omitempty"`

  // Code specifying the identity of a party.
  PartyIdentifier string `json:"partyIdentifier"`
}

// PARTYNAME Identification of a transaction party by name, one to five lines. Party name may be formatted. 
type PARTYNAME struct {

  // Name of a party.
  PartyName string `json:"partyName"`
}

// PERCENTAGEDETAILS Percentage relating to a specified basis. 
type PERCENTAGEDETAILS struct {

  // To specify a percentage.
  Percentage float64 `json:"percentage,omitempty"`

  // Code qualifying the type of percentage.: (9) Adjustment
  PercentageTypeCodeQualifier string `json:"percentageTypeCodeQualifier,omitempty"`
}

// PROCESSINGINDICATOR Identification of the processing indicator. 
type PROCESSINGINDICATOR struct {

  // Code identifying a user or association maintained code list.
  CodeListIdentificationCode string `json:"codeListIdentificationCode,omitempty"`

  // Code specifying the agency responsible for a code list.: (109) GB, H.M. Customs & Excise
  CodeListResponsibleAgencyCode string `json:"codeListResponsibleAgencyCode,omitempty"`

  // Code specifying a processing indicator.
  ProcessingIndicatorDescriptionCode string `json:"processingIndicatorDescriptionCode,omitempty"`
}

// PartyDeclaringTheValueAddedTaxVAT A code to identify the party who is responsible for declaring the Value Added Tax (VAT) on the sale of goods or services.
type PartyDeclaringTheValueAddedTaxVAT struct {

  // Code giving specific meaning to a party.: (LC) Party declaring the Value Added Tax (VAT)
  PartyFunctionCodeQualifier string `json:"partyFunctionCodeQualifier,omitempty"`

  // Identification of a transaction party by code. 
  PartyIdentificationDetails *PARTYIDENTIFICATIONDETAILS `json:"partyIdentificationDetails,omitempty"`
}

// PlaceOfArrival Place at which the transport means arrives.
type PlaceOfArrival struct {

  // Code identifying the function of a location.: (60) Place of arrival
  LocationFunctionCodeQualifier string `json:"locationFunctionCodeQualifier,omitempty"`

  // Identification of a location by code or name. 
  LocationIdentification *LOCATIONIDENTIFICATION `json:"locationIdentification,omitempty"`
}

// PlaceOfAuthenticationOfDocument (3410) Place where document is signed or otherwise authenticated. Synonym: Place of issue of document.
type PlaceOfAuthenticationOfDocument struct {

  // Code identifying the function of a location.: (44) Place of authentication of document
  LocationFunctionCodeQualifier string `json:"locationFunctionCodeQualifier,omitempty"`

  // Identification of a location by code or name. 
  LocationIdentification *LOCATIONIDENTIFICATION `json:"locationIdentification,omitempty"`

  // Identification the first related location by code or name. 
  RelatedLocationOneIdentification *RELATEDLOCATIONONEIDENTIFICATION `json:"relatedLocationOneIdentification,omitempty"`
}

// PlacePortOfDischarge (3392 + 3414) Seaport, airport, freight terminal, rail station or other place at which the goods (cargo) are unloaded from the means of transport having been used for their carriage.
type PlacePortOfDischarge struct {

  // Code identifying the function of a location.: (11) Place/port of discharge
  LocationFunctionCodeQualifier string `json:"locationFunctionCodeQualifier,omitempty"`

  // Identification of a location by code or name. 
  LocationIdentification *LOCATIONIDENTIFICATION `json:"locationIdentification,omitempty"`
}

// PlacePortOfLoading (3334 + 3230) Seaport, airport, freight terminal, rail station or other place at which the goods (cargo) are loaded on to the means of transport being used for their carriage.
type PlacePortOfLoading struct {

  // Code identifying the function of a location.: (9) Place/port of loading
  LocationFunctionCodeQualifier string `json:"locationFunctionCodeQualifier,omitempty"`

  // Identification of a location by code or name. 
  LocationIdentification *LOCATIONIDENTIFICATION `json:"locationIdentification,omitempty"`
}

// PresentationDateLatest Latest date for presentation of a document.
type PresentationDateLatest struct {

  // Date and/or time, or period relevant to the specified date/time/period type. 
  DateTimePeriod *DATETIMEPERIOD `json:"dateTimePeriod,omitempty"`
}

// PreviousCustomsDocumentMessage Indication of the previous Customs document/message concerning the same transaction.
type PreviousCustomsDocumentMessage struct {

  // Identification of document/message by number, status, source and/or language. 
  DocumentMessageDetails *DOCUMENTMESSAGEDETAILS `json:"documentMessageDetails,omitempty"`

  // Identification of a type of document/message by code or name. Code preferred. 
  DocumentMessageName *DOCUMENTMESSAGENAME `json:"documentMessageName,omitempty"`
}

// PrimeContractor Party responsible for the whole project if other than the buyer.
type PrimeContractor struct {

  // Code giving specific meaning to a party.: (PG) Prime contractor
  PartyFunctionCodeQualifier string `json:"partyFunctionCodeQualifier,omitempty"`

  // Identification of a transaction party by code. 
  PartyIdentificationDetails *PARTYIDENTIFICATIONDETAILS `json:"partyIdentificationDetails,omitempty"`
}

// Product A product from Acme's catalog
type Product struct {

  // The unique identifier for a product
  ProductId int `json:"productId"`
}

// QuotaNumber Reference number allocated by a government authority to identify a quota.
type QuotaNumber struct {

  // Identification of a reference. 
  Reference *REFERENCE `json:"reference,omitempty"`
}

// REFERENCE Identification of a reference. 
type REFERENCE struct {

  // Code qualifying a reference.: (UCN) Unique consignment reference number
  ReferenceCodeQualifier string `json:"referenceCodeQualifier,omitempty"`

  // Identifies a reference.
  ReferenceIdentifier string `json:"referenceIdentifier,omitempty"`
}

// REFERENCEIDENTIFICATION REFERENCE IDENTIFICATION.
type REFERENCEIDENTIFICATION struct {

  // Reference identification number.
  ReferenceIdentificationNumber string `json:"referenceIdentificationNumber"`

  // Reference qualifier.
  ReferenceQualifier string `json:"referenceQualifier"`
}

// REFERENCEItemsItems 
type REFERENCEItemsItems struct {

  // Identification of a reference. 
  Reference *REFERENCE `json:"reference,omitempty"`
}

// RELATEDLOCATIONONEIDENTIFICATION Identification the first related location by code or name. 
type RELATEDLOCATIONONEIDENTIFICATION struct {

  // Code specifying first related location.
  FirstRelatedLocationNameCode string `json:"firstRelatedLocationNameCode,omitempty"`
}

// RelatedDocument Document that has a relationship with the stated document/message.
type RelatedDocument struct {

  // Identification of document/message by number, status, source and/or language. 
  DocumentMessageDetails *DOCUMENTMESSAGEDETAILS `json:"documentMessageDetails,omitempty"`

  // Identification of a type of document/message by code or name. Code preferred. 
  DocumentMessageName *DOCUMENTMESSAGENAME `json:"documentMessageName,omitempty"`
}

// Root 
type Root struct {

  // [2036] Date on which a Goods declaration is accepted by Customs in accordance with Customs legislation.
  AcceptanceDateOfGoodsDeclarationCustoms *AcceptanceDateOfGoodsDeclarationCustoms `json:"acceptanceDateOfGoodsDeclarationCustoms,omitempty"`

  //  A segment identifying the type and the reference number of the message to which the CUSRES is a response.
  BeginningOfMessage *BEGINNINGOFMESSAGE `json:"beginningOfMessage,omitempty"`

  // GRP3 -  A group of segments identifying references, dates and locations related information.
  CustomsDeclarationNumber *GRP3 `json:"customsDeclarationNumber,omitempty"`

  // (3080) Place where Customs clearance procedure occur (CCC).
  CustomsOfficeOfClearance *CustomsOfficeOfClearance `json:"customsOfficeOfClearance,omitempty"`

  // GRP3 -  A group of segments identifying references, dates and locations related information.
  CustomsReleaseCode *GRP3 `json:"customsReleaseCode,omitempty"`

  // GRP3 -  A group of segments identifying references, dates and locations related information.
  DeclarantUniqueConsignmentReference *GRP3 `json:"declarantUniqueConsignmentReference,omitempty"`

  // GRP6 -  A group of segments specifying goods item details including status of goods, related references, package identification, details of transport, relevant parties, contacts, dates and/or times and location, general indicators, measurements, documentary requirements, monetary amounts, currencies and item taxes, fees and duties.
  DeclarationResponseDetail *GRP6 `json:"declarationResponseDetail,omitempty"`

  // (2069) Date and/or time at which specified event or document becomes effective.
  EffectiveFromDateTime *EffectiveFromDateTime `json:"effectiveFromDateTime,omitempty"`

  // GRP3 -  A group of segments identifying references, dates and locations related information.
  GoodsDeclarationNumber *GRP3 `json:"goodsDeclarationNumber,omitempty"`

  // GRP4 -  A group of segments identifying an application error condition within a message to which the CUSRES is a response.
  Grp4 []*GRP4Items `json:"grp4,omitempty"`

  // GRP3 -  A group of segments identifying references, dates and locations related information.
  ImportClearanceInstructionReferenceNumber *GRP3 `json:"importClearanceInstructionReferenceNumber,omitempty"`

  // Interchange Header Segment
  InterchangeHeader *InterchangeHeader `json:"interchangeHeader,omitempty"`

  // Close of the Interchange message.
  InterchangeTrailer *InterchangeTrailer `json:"interchangeTrailer,omitempty"`

  // [3384] Place where goods are located.
  LocationOfGoods *LocationOfGoods `json:"locationOfGoods,omitempty"`

  //  A service segment starting and uniquely identifying a message. The message type code for the Customs response message is CUSRES.
  MessageHeader *MESSAGEHEADER `json:"messageHeader,omitempty"`

  //  A service segment ending a message, giving the total number of segments in the message (including the UNH & UNT) and the control reference number of the message.
  MessageTrailer *MESSAGETRAILER `json:"messageTrailer,omitempty"`

  // (3410) Place where document is signed or otherwise authenticated. Synonym: Place of issue of document.
  PlaceOfAuthenticationOfDocument *PlaceOfAuthenticationOfDocument `json:"placeOfAuthenticationOfDocument,omitempty"`

  // Latest date for presentation of a document.
  PresentationDateLatest *PresentationDateLatest `json:"presentationDateLatest,omitempty"`

  // GRP3 -  A group of segments identifying references, dates and locations related information.
  UniqueConsignmentReferenceNumber *GRP3 `json:"uniqueConsignmentReferenceNumber,omitempty"`
}

// SCENARIOIDENTIFICATION Identification of a scenario. 
type SCENARIOIDENTIFICATION struct {

  // Code identifying a controlling agency.
  ControllingAgencyCoded string `json:"controllingAgencyCoded,omitempty"`

  // Code identifying scenario.
  ScenarioIdentification string `json:"scenarioIdentification"`

  // Release number within the scenario version number.
  ScenarioReleaseNumber string `json:"scenarioReleaseNumber,omitempty"`

  // Version number of a scenario.
  ScenarioVersionNumber string `json:"scenarioVersionNumber,omitempty"`
}

// STATUSOFTHETRANSFER Statement that the message is one in a sequence of transfers relating to the same topic. 
type STATUSOFTHETRANSFER struct {

  // Indication used for the first and last message in a sequence of messages related to the same topic.
  FirstAndLastTransfer string `json:"firstAndLastTransfer,omitempty"`

  // Number assigned by the sender indicating the transfer sequence of a message related to the same topic. The message could be an addition or a change to an earlier transfer related to the same topic.
  SequenceOfTransfers float64 `json:"sequenceOfTransfers"`
}

// STREET Street address and/or PO Box number in a structured address: one to four lines. 
type STREET struct {

  // To identify a street and number and/or Post Office box number.
  StreetAndNumberOrPostOfficeBoxIdentifier string `json:"streetAndNumberOrPostOfficeBoxIdentifier,omitempty"`
}

// SYNTAX Identification of the agency controlling the syntax and indication of syntax level.
type SYNTAX struct {

  // Coded identification of the agency controlling a syntax and syntax level used in an interchange.
  SyntaxIdentifier string `json:"syntaxIdentifier,omitempty"`

  // Version number of the syntax identified in the syntax identifier (0001).
  SyntaxTypeVersionNumber string `json:"syntaxTypeVersionNumber,omitempty"`
}

// SegmentErrorIndication Segment error indication.
type SegmentErrorIndication struct {

  // Segment position in message body.
  SegmentPositionInMessageBody float64 `json:"segmentPositionInMessageBody"`

  // Syntax error, coded.
  SyntaxErrorCoded string `json:"syntaxErrorCoded,omitempty"`
}

// SingleAdministrativeDocument A set of documents, replacing the various (national) forms for Customs declaration within the EC, implemented on 01-01-1988.
type SingleAdministrativeDocument struct {

  // Identification of document/message by number, status, source and/or language. 
  DocumentMessageDetails *DOCUMENTMESSAGEDETAILS `json:"documentMessageDetails,omitempty"`

  // Identification of a type of document/message by code or name. Code preferred. 
  DocumentMessageName *DOCUMENTMESSAGENAME `json:"documentMessageName,omitempty"`
}

// StatisticalValue [5218] Value declared for statistical purposes of those goods in a consignment which have the same statistical heading and country of origin.
type StatisticalValue struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// TERMSOFDELIVERYORTRANSPORT  A segment identifying terms of delivery, relevant to the entire message, in a coded format.
type TERMSOFDELIVERYORTRANSPORT struct {

  // Code specifying the function of delivery or transport terms.
  DeliveryOrTransportTermsFunctionCode string `json:"deliveryOrTransportTermsFunctionCode,omitempty"`

  // Code specifying the payment method for transport charges.
  TransportChargesPaymentMethodCode string `json:"transportChargesPaymentMethodCode,omitempty"`
}

// TEXTLITERAL Free text; one to five lines. 
type TEXTLITERAL struct {

  // Free form text.
  FreeText1 string `json:"freeText_1,omitempty"`

  // Free form text.
  FreeText2 string `json:"freeText_2,omitempty"`

  // Free form text.
  FreeText3 string `json:"freeText_3,omitempty"`

  // Free form text.
  FreeText4 string `json:"freeText_4,omitempty"`

  // Free form text.
  FreeText5 string `json:"freeText_5,omitempty"`
}

// TEXTREFERENCE Coded reference to a standard text and its source. 
type TEXTREFERENCE struct {

  // Code identifying a user or association maintained code list.
  CodeListIdentificationCode string `json:"codeListIdentificationCode,omitempty"`

  // Code specifying the agency responsible for a code list.
  CodeListResponsibleAgencyCode string `json:"codeListResponsibleAgencyCode,omitempty"`

  // Code specifying free form text.
  FreeTextDescriptionCode string `json:"freeTextDescriptionCode,omitempty"`
}

// TRANSPORTIDENTIFICATION Code and/or name identifying the means of transport. 
type TRANSPORTIDENTIFICATION struct {

  // Code identifying a user or association maintained code list.
  CodeListIdentificationCode string `json:"codeListIdentificationCode,omitempty"`

  // Code specifying the agency responsible for a code list.
  CodeListResponsibleAgencyCode string `json:"codeListResponsibleAgencyCode,omitempty"`

  // Name identifying a means of transport.
  TransportMeansIdentificationName string `json:"transportMeansIdentificationName,omitempty"`

  // Identifies the name of the transport means.
  TransportMeansIdentificationNameIdentifier string `json:"transportMeansIdentificationNameIdentifier,omitempty"`

  // Code specifying the nationality of a means of transport.
  TransportMeansNationalityCode string `json:"transportMeansNationalityCode,omitempty"`
}

// TRANSPORTMEANS Code and/or name identifying the type of means of transport. 
type TRANSPORTMEANS struct {

  // Code identifying a user or association maintained code list.
  CodeListIdentificationCode string `json:"codeListIdentificationCode,omitempty"`

  // Code specifying the agency responsible for a code list.
  CodeListResponsibleAgencyCode string `json:"codeListResponsibleAgencyCode,omitempty"`

  // Free form description of the means of transport.
  TransportMeansDescription string `json:"transportMeansDescription,omitempty"`

  // Code specifying the means of transport.
  TransportMeansDescriptionCode string `json:"transportMeansDescriptionCode,omitempty"`
}

// TotalNumberOfPackages [7370] Total number of packages of the entire consignment.
type TotalNumberOfPackages struct {

  // Control total for checking integrity of a message or part of a message. 
  Control *CONTROL `json:"control,omitempty"`
}

// TotalOfEachDutyTaxOrFeeTypeCustomsDeclaration Total of each duty, tax or fee charged on the goods declaration (CCC).
type TotalOfEachDutyTaxOrFeeTypeCustomsDeclaration struct {

  // Code qualifying the function of a duty or tax or fee.: (3) Total of each duty, tax or fee type (Customs declaration)
  DutyOrTaxOrFeeFunctionCodeQualifier string `json:"dutyOrTaxOrFeeFunctionCodeQualifier,omitempty"`

  // Indication of account reference for duties, taxes and/or fees. 
  DutyTaxFeeAccountDetail *DUTYTAXFEEACCOUNTDETAIL `json:"dutyTaxFeeAccountDetail,omitempty"`

  // Code and/or name identifying duty, tax or fee. 
  DutyTaxFeeType *DUTYTAXFEETYPE `json:"dutyTaxFeeType,omitempty"`
}

// TransportChargesCustoms (5292) Cost incurred by shipper in moving goods, by whatever means, from one place to another under the terms of the contract of carriage, see UN/ECE Recommendation No 23. Synonym: freight charges (Customs).
type TransportChargesCustoms struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// TransportMeansArrivalDateTimeEstimated [2348] Date/time when carrier estimates that a means of transport should arrive at the port of discharge or place of destination.
type TransportMeansArrivalDateTimeEstimated struct {

  // Date and/or time, or period relevant to the specified date/time/period type. 
  DateTimePeriod *DATETIMEPERIOD `json:"dateTimePeriod,omitempty"`
}

// UniqueConsignmentReferenceNumber (1202) Unique reference of a consignment (UCRN) used for identification purposes in documents and messages exchanged between parties in international trade. See also: Unique Identifier Code (UNIC) in UN/ECE Recommendation No. 8, March 1992.
type UniqueConsignmentReferenceNumber struct {

  // Identification of a reference. 
  Reference *REFERENCE `json:"reference,omitempty"`
}

// UnitLoadDeviceEGContainerIdentificationNumber [8260] Marks (letters and/or numbers) which identify a unit load device e.g. freight container.
type UnitLoadDeviceEGContainerIdentificationNumber struct {

  // Identification of a reference. 
  Reference *REFERENCE `json:"reference,omitempty"`
}

// UnitedNationsDangerousGoodsUNDGNumber [7124] Unique serial number assigned within the United Nations to substances and articles contained in a list of the dangerous goods most commonly carried.
type UnitedNationsDangerousGoodsUNDGNumber struct {

  // Identification of a reference. 
  Reference *REFERENCE `json:"reference,omitempty"`
}

// VALUERANGE Measurement value and relevant minimum and maximum values of the measurement range. 
type VALUERANGE struct {

  // To specify the value of a measurement.
  Measure string `json:"measure,omitempty"`

  // Code specifying the unit of measurement.
  MeasurementUnitCode string `json:"measurementUnitCode,omitempty"`
}

// VAT1stValue First VAT value if, for the same rate of VAT, there are 1 to 3 different ways to set this value.
type VAT1stValue struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// ValueAddedTax [5490] Amount in national currency resulting from the application, at the appropriate rate, of value added tax (or similar tax) to the invoice amount subject to such tax.
type ValueAddedTax struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// WarehouseKeeper (3022) Party taking responsibility for goods entered into a warehouse.
type WarehouseKeeper struct {

  // Name of a city.
  CityName string `json:"cityName,omitempty"`

  // Identification of the name of the country or other geographical entity as defined in ISO 3166-1.
  CountryNameCode string `json:"countryNameCode,omitempty"`

  // To specify a part of a country (eg county or part of a city). 
  CountrySubEntityDetails *COUNTRYSUBENTITYDETAILS `json:"countrySubEntityDetails,omitempty"`

  // Unstructured name and address: one to five lines. 
  NameAndAddress *NAMEANDADDRESS `json:"nameAndAddress,omitempty"`

  // Code giving specific meaning to a party.: (WH) Warehouse keeper
  PartyFunctionCodeQualifier string `json:"partyFunctionCodeQualifier,omitempty"`

  // Identification of a transaction party by code. 
  PartyIdentificationDetails *PARTYIDENTIFICATIONDETAILS `json:"partyIdentificationDetails,omitempty"`

  // Identification of a transaction party by name, one to five lines. Party name may be formatted. 
  PartyName *PARTYNAME `json:"partyName,omitempty"`

  // Code specifying the postal zone or address.
  PostalIdentificationCode string `json:"postalIdentificationCode,omitempty"`

  // Street address and/or PO Box number in a structured address: one to four lines. 
  Street *STREET `json:"street,omitempty"`
}

// _1stSpecifiedTariffQuantity Primary reportable quantity associated with a tariff number.
type _1stSpecifiedTariffQuantity struct {

  // Identification of measurement type. 
  MeasurementDetails *MEASUREMENTDETAILS `json:"measurementDetails,omitempty"`

  // Code qualifying the purpose of the measurement.: (AAR) 1st specified tariff quantity
  MeasurementPurposeCodeQualifier string `json:"measurementPurposeCodeQualifier,omitempty"`

  // Measurement value and relevant minimum and maximum values of the measurement range. 
  ValueRange *VALUERANGE `json:"valueRange,omitempty"`
}

// _2ndSpecifiedTariffQuantity Secondary reportable quantity associated with a tariff number.
type _2ndSpecifiedTariffQuantity struct {

  // Identification of measurement type. 
  MeasurementDetails *MEASUREMENTDETAILS `json:"measurementDetails,omitempty"`

  // Code qualifying the purpose of the measurement.: (AAS) 2nd specified tariff quantity
  MeasurementPurposeCodeQualifier string `json:"measurementPurposeCodeQualifier,omitempty"`

  // Measurement value and relevant minimum and maximum values of the measurement range. 
  ValueRange *VALUERANGE `json:"valueRange,omitempty"`
}

// _3rdSpecifiedTariffQuantity Third reportable quantity associated with a tariff number.
type _3rdSpecifiedTariffQuantity struct {

  // Identification of measurement type. 
  MeasurementDetails *MEASUREMENTDETAILS `json:"measurementDetails,omitempty"`

  // Code qualifying the purpose of the measurement.: (AAT) 3rd specified tariff quantity
  MeasurementPurposeCodeQualifier string `json:"measurementPurposeCodeQualifier,omitempty"`

  // Measurement value and relevant minimum and maximum values of the measurement range. 
  ValueRange *VALUERANGE `json:"valueRange,omitempty"`
}

func (strct *APPLICATIONRECIPIENTIDENTIFICATION) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ApplicationRecipientIdentification" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "applicationRecipientIdentification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"applicationRecipientIdentification\": ")
	if tmp, err := json.Marshal(strct.ApplicationRecipientIdentification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "identificationCodeQualifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"identificationCodeQualifier\": ")
	if tmp, err := json.Marshal(strct.IdentificationCodeQualifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *APPLICATIONRECIPIENTIDENTIFICATION) UnmarshalJSON(b []byte) error {
    applicationRecipientIdentificationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "applicationRecipientIdentification":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationRecipientIdentification); err != nil {
                return err
             }
            applicationRecipientIdentificationReceived = true
        case "identificationCodeQualifier":
            if err := json.Unmarshal([]byte(v), &strct.IdentificationCodeQualifier); err != nil {
                return err
             }
        }
    }
    // check if applicationRecipientIdentification (a required property) was received
    if !applicationRecipientIdentificationReceived {
        return errors.New("\"applicationRecipientIdentification\" is required but was not present")
    }
    return nil
}

func (strct *APPLICATIONSENDERIDENTIFICATION) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ApplicationSenderIdentification" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "applicationSenderIdentification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"applicationSenderIdentification\": ")
	if tmp, err := json.Marshal(strct.ApplicationSenderIdentification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "identificationCodeQualifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"identificationCodeQualifier\": ")
	if tmp, err := json.Marshal(strct.IdentificationCodeQualifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *APPLICATIONSENDERIDENTIFICATION) UnmarshalJSON(b []byte) error {
    applicationSenderIdentificationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "applicationSenderIdentification":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationSenderIdentification); err != nil {
                return err
             }
            applicationSenderIdentificationReceived = true
        case "identificationCodeQualifier":
            if err := json.Unmarshal([]byte(v), &strct.IdentificationCodeQualifier); err != nil {
                return err
             }
        }
    }
    // check if applicationSenderIdentification (a required property) was received
    if !applicationSenderIdentificationReceived {
        return errors.New("\"applicationSenderIdentification\" is required but was not present")
    }
    return nil
}

func (strct *COMMUNICATIONCONTACT) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CommunicationAddressCodeQualifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "communicationAddressCodeQualifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"communicationAddressCodeQualifier\": ")
	if tmp, err := json.Marshal(strct.CommunicationAddressCodeQualifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "CommunicationAddressIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "communicationAddressIdentifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"communicationAddressIdentifier\": ")
	if tmp, err := json.Marshal(strct.CommunicationAddressIdentifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *COMMUNICATIONCONTACT) UnmarshalJSON(b []byte) error {
    communicationAddressCodeQualifierReceived := false
    communicationAddressIdentifierReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "communicationAddressCodeQualifier":
            if err := json.Unmarshal([]byte(v), &strct.CommunicationAddressCodeQualifier); err != nil {
                return err
             }
            communicationAddressCodeQualifierReceived = true
        case "communicationAddressIdentifier":
            if err := json.Unmarshal([]byte(v), &strct.CommunicationAddressIdentifier); err != nil {
                return err
             }
            communicationAddressIdentifierReceived = true
        }
    }
    // check if communicationAddressCodeQualifier (a required property) was received
    if !communicationAddressCodeQualifierReceived {
        return errors.New("\"communicationAddressCodeQualifier\" is required but was not present")
    }
    // check if communicationAddressIdentifier (a required property) was received
    if !communicationAddressIdentifierReceived {
        return errors.New("\"communicationAddressIdentifier\" is required but was not present")
    }
    return nil
}

func (strct *CURRENCYDETAILS) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "currencyIdentificationCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"currencyIdentificationCode\": ")
	if tmp, err := json.Marshal(strct.CurrencyIdentificationCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "currencyRate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"currencyRate\": ")
	if tmp, err := json.Marshal(strct.CurrencyRate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "currencyTypeCodeQualifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"currencyTypeCodeQualifier\": ")
	if tmp, err := json.Marshal(strct.CurrencyTypeCodeQualifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "CurrencyUsageCodeQualifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "currencyUsageCodeQualifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"currencyUsageCodeQualifier\": ")
	if tmp, err := json.Marshal(strct.CurrencyUsageCodeQualifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CURRENCYDETAILS) UnmarshalJSON(b []byte) error {
    currencyUsageCodeQualifierReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "currencyIdentificationCode":
            if err := json.Unmarshal([]byte(v), &strct.CurrencyIdentificationCode); err != nil {
                return err
             }
        case "currencyRate":
            if err := json.Unmarshal([]byte(v), &strct.CurrencyRate); err != nil {
                return err
             }
        case "currencyTypeCodeQualifier":
            if err := json.Unmarshal([]byte(v), &strct.CurrencyTypeCodeQualifier); err != nil {
                return err
             }
        case "currencyUsageCodeQualifier":
            if err := json.Unmarshal([]byte(v), &strct.CurrencyUsageCodeQualifier); err != nil {
                return err
             }
            currencyUsageCodeQualifierReceived = true
        }
    }
    // check if currencyUsageCodeQualifier (a required property) was received
    if !currencyUsageCodeQualifierReceived {
        return errors.New("\"currencyUsageCodeQualifier\" is required but was not present")
    }
    return nil
}

func (strct *CUSTOMSSTATUSOFGOODS) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "GoodsItemNumber" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "goodsItemNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"goodsItemNumber\": ")
	if tmp, err := json.Marshal(strct.GoodsItemNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CUSTOMSSTATUSOFGOODS) UnmarshalJSON(b []byte) error {
    goodsItemNumberReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "goodsItemNumber":
            if err := json.Unmarshal([]byte(v), &strct.GoodsItemNumber); err != nil {
                return err
             }
            goodsItemNumberReceived = true
        }
    }
    // check if goodsItemNumber (a required property) was received
    if !goodsItemNumberReceived {
        return errors.New("\"goodsItemNumber\" is required but was not present")
    }
    return nil
}

func (strct *Consignor) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CityName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "cityName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"cityName\": ")
	if tmp, err := json.Marshal(strct.CityName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "CountryNameCode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "countryNameCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"countryNameCode\": ")
	if tmp, err := json.Marshal(strct.CountryNameCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "countrySubEntityDetails" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"countrySubEntityDetails\": ")
	if tmp, err := json.Marshal(strct.CountrySubEntityDetails); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "nameAndAddress" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"nameAndAddress\": ")
	if tmp, err := json.Marshal(strct.NameAndAddress); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "partyFunctionCodeQualifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"partyFunctionCodeQualifier\": ")
	if tmp, err := json.Marshal(strct.PartyFunctionCodeQualifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "partyIdentificationDetails" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"partyIdentificationDetails\": ")
	if tmp, err := json.Marshal(strct.PartyIdentificationDetails); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "partyName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"partyName\": ")
	if tmp, err := json.Marshal(strct.PartyName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PostalIdentificationCode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "postalIdentificationCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"postalIdentificationCode\": ")
	if tmp, err := json.Marshal(strct.PostalIdentificationCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "street" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"street\": ")
	if tmp, err := json.Marshal(strct.Street); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Consignor) UnmarshalJSON(b []byte) error {
    cityNameReceived := false
    countryNameCodeReceived := false
    postalIdentificationCodeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "cityName":
            if err := json.Unmarshal([]byte(v), &strct.CityName); err != nil {
                return err
             }
            cityNameReceived = true
        case "countryNameCode":
            if err := json.Unmarshal([]byte(v), &strct.CountryNameCode); err != nil {
                return err
             }
            countryNameCodeReceived = true
        case "countrySubEntityDetails":
            if err := json.Unmarshal([]byte(v), &strct.CountrySubEntityDetails); err != nil {
                return err
             }
        case "nameAndAddress":
            if err := json.Unmarshal([]byte(v), &strct.NameAndAddress); err != nil {
                return err
             }
        case "partyFunctionCodeQualifier":
            if err := json.Unmarshal([]byte(v), &strct.PartyFunctionCodeQualifier); err != nil {
                return err
             }
        case "partyIdentificationDetails":
            if err := json.Unmarshal([]byte(v), &strct.PartyIdentificationDetails); err != nil {
                return err
             }
        case "partyName":
            if err := json.Unmarshal([]byte(v), &strct.PartyName); err != nil {
                return err
             }
        case "postalIdentificationCode":
            if err := json.Unmarshal([]byte(v), &strct.PostalIdentificationCode); err != nil {
                return err
             }
            postalIdentificationCodeReceived = true
        case "street":
            if err := json.Unmarshal([]byte(v), &strct.Street); err != nil {
                return err
             }
        }
    }
    // check if cityName (a required property) was received
    if !cityNameReceived {
        return errors.New("\"cityName\" is required but was not present")
    }
    // check if countryNameCode (a required property) was received
    if !countryNameCodeReceived {
        return errors.New("\"countryNameCode\" is required but was not present")
    }
    // check if postalIdentificationCode (a required property) was received
    if !postalIdentificationCodeReceived {
        return errors.New("\"postalIdentificationCode\" is required but was not present")
    }
    return nil
}

func (strct *DATAELEMENTIDENTIFICATION) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "erroneousComponentDataElementPosition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"erroneousComponentDataElementPosition\": ")
	if tmp, err := json.Marshal(strct.ErroneousComponentDataElementPosition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "erroneousDataElementOccurrence" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"erroneousDataElementOccurrence\": ")
	if tmp, err := json.Marshal(strct.ErroneousDataElementOccurrence); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ErroneousDataElementPositionInSegment" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "erroneousDataElementPositionInSegment" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"erroneousDataElementPositionInSegment\": ")
	if tmp, err := json.Marshal(strct.ErroneousDataElementPositionInSegment); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DATAELEMENTIDENTIFICATION) UnmarshalJSON(b []byte) error {
    erroneousDataElementPositionInSegmentReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "erroneousComponentDataElementPosition":
            if err := json.Unmarshal([]byte(v), &strct.ErroneousComponentDataElementPosition); err != nil {
                return err
             }
        case "erroneousDataElementOccurrence":
            if err := json.Unmarshal([]byte(v), &strct.ErroneousDataElementOccurrence); err != nil {
                return err
             }
        case "erroneousDataElementPositionInSegment":
            if err := json.Unmarshal([]byte(v), &strct.ErroneousDataElementPositionInSegment); err != nil {
                return err
             }
            erroneousDataElementPositionInSegmentReceived = true
        }
    }
    // check if erroneousDataElementPositionInSegment (a required property) was received
    if !erroneousDataElementPositionInSegmentReceived {
        return errors.New("\"erroneousDataElementPositionInSegment\" is required but was not present")
    }
    return nil
}

func (strct *DUTYTAXFEETYPE) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DutyOrTaxOrFeeTypeNameCode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "dutyOrTaxOrFeeTypeNameCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"dutyOrTaxOrFeeTypeNameCode\": ")
	if tmp, err := json.Marshal(strct.DutyOrTaxOrFeeTypeNameCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DUTYTAXFEETYPE) UnmarshalJSON(b []byte) error {
    dutyOrTaxOrFeeTypeNameCodeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "dutyOrTaxOrFeeTypeNameCode":
            if err := json.Unmarshal([]byte(v), &strct.DutyOrTaxOrFeeTypeNameCode); err != nil {
                return err
             }
            dutyOrTaxOrFeeTypeNameCodeReceived = true
        }
    }
    // check if dutyOrTaxOrFeeTypeNameCode (a required property) was received
    if !dutyOrTaxOrFeeTypeNameCodeReceived {
        return errors.New("\"dutyOrTaxOrFeeTypeNameCode\" is required but was not present")
    }
    return nil
}

func (strct *DataElementErrorIndicationItemsItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "dataElementIdentification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"dataElementIdentification\": ")
	if tmp, err := json.Marshal(strct.DataElementIdentification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SyntaxErrorCoded" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "syntaxErrorCoded" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"syntaxErrorCoded\": ")
	if tmp, err := json.Marshal(strct.SyntaxErrorCoded); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DataElementErrorIndicationItemsItems) UnmarshalJSON(b []byte) error {
    syntaxErrorCodedReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "dataElementIdentification":
            if err := json.Unmarshal([]byte(v), &strct.DataElementIdentification); err != nil {
                return err
             }
        case "syntaxErrorCoded":
            if err := json.Unmarshal([]byte(v), &strct.SyntaxErrorCoded); err != nil {
                return err
             }
            syntaxErrorCodedReceived = true
        }
    }
    // check if syntaxErrorCoded (a required property) was received
    if !syntaxErrorCodedReceived {
        return errors.New("\"syntaxErrorCoded\" is required but was not present")
    }
    return nil
}

func (strct *DataElementErrorIndicationsItemsItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "dataElementIdentification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"dataElementIdentification\": ")
	if tmp, err := json.Marshal(strct.DataElementIdentification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SyntaxErrorCoded" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "syntaxErrorCoded" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"syntaxErrorCoded\": ")
	if tmp, err := json.Marshal(strct.SyntaxErrorCoded); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DataElementErrorIndicationsItemsItems) UnmarshalJSON(b []byte) error {
    syntaxErrorCodedReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "dataElementIdentification":
            if err := json.Unmarshal([]byte(v), &strct.DataElementIdentification); err != nil {
                return err
             }
        case "syntaxErrorCoded":
            if err := json.Unmarshal([]byte(v), &strct.SyntaxErrorCoded); err != nil {
                return err
             }
            syntaxErrorCodedReceived = true
        }
    }
    // check if syntaxErrorCoded (a required property) was received
    if !syntaxErrorCodedReceived {
        return errors.New("\"syntaxErrorCoded\" is required but was not present")
    }
    return nil
}

func (strct *EXCESSTRANSPORTATIONINFORMATION) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "customerShipmentAuthorisationIdentifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"customerShipmentAuthorisationIdentifier\": ")
	if tmp, err := json.Marshal(strct.CustomerShipmentAuthorisationIdentifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ExcessTransportationReasonCode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "excessTransportationReasonCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"excessTransportationReasonCode\": ")
	if tmp, err := json.Marshal(strct.ExcessTransportationReasonCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ExcessTransportationResponsibilityCode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "excessTransportationResponsibilityCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"excessTransportationResponsibilityCode\": ")
	if tmp, err := json.Marshal(strct.ExcessTransportationResponsibilityCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EXCESSTRANSPORTATIONINFORMATION) UnmarshalJSON(b []byte) error {
    excessTransportationReasonCodeReceived := false
    excessTransportationResponsibilityCodeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "customerShipmentAuthorisationIdentifier":
            if err := json.Unmarshal([]byte(v), &strct.CustomerShipmentAuthorisationIdentifier); err != nil {
                return err
             }
        case "excessTransportationReasonCode":
            if err := json.Unmarshal([]byte(v), &strct.ExcessTransportationReasonCode); err != nil {
                return err
             }
            excessTransportationReasonCodeReceived = true
        case "excessTransportationResponsibilityCode":
            if err := json.Unmarshal([]byte(v), &strct.ExcessTransportationResponsibilityCode); err != nil {
                return err
             }
            excessTransportationResponsibilityCodeReceived = true
        }
    }
    // check if excessTransportationReasonCode (a required property) was received
    if !excessTransportationReasonCodeReceived {
        return errors.New("\"excessTransportationReasonCode\" is required but was not present")
    }
    // check if excessTransportationResponsibilityCode (a required property) was received
    if !excessTransportationResponsibilityCodeReceived {
        return errors.New("\"excessTransportationResponsibilityCode\" is required but was not present")
    }
    return nil
}

func (strct *FREETEXT) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "freeTextFormatCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"freeTextFormatCode\": ")
	if tmp, err := json.Marshal(strct.FreeTextFormatCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "freeTextFunctionCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"freeTextFunctionCode\": ")
	if tmp, err := json.Marshal(strct.FreeTextFunctionCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "languageNameCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"languageNameCode\": ")
	if tmp, err := json.Marshal(strct.LanguageNameCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "textLiteral" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"textLiteral\": ")
	if tmp, err := json.Marshal(strct.TextLiteral); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "textReference" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"textReference\": ")
	if tmp, err := json.Marshal(strct.TextReference); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TextSubjectCodeQualifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "textSubjectCodeQualifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"textSubjectCodeQualifier\": ")
	if tmp, err := json.Marshal(strct.TextSubjectCodeQualifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FREETEXT) UnmarshalJSON(b []byte) error {
    textSubjectCodeQualifierReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "freeTextFormatCode":
            if err := json.Unmarshal([]byte(v), &strct.FreeTextFormatCode); err != nil {
                return err
             }
        case "freeTextFunctionCode":
            if err := json.Unmarshal([]byte(v), &strct.FreeTextFunctionCode); err != nil {
                return err
             }
        case "languageNameCode":
            if err := json.Unmarshal([]byte(v), &strct.LanguageNameCode); err != nil {
                return err
             }
        case "textLiteral":
            if err := json.Unmarshal([]byte(v), &strct.TextLiteral); err != nil {
                return err
             }
        case "textReference":
            if err := json.Unmarshal([]byte(v), &strct.TextReference); err != nil {
                return err
             }
        case "textSubjectCodeQualifier":
            if err := json.Unmarshal([]byte(v), &strct.TextSubjectCodeQualifier); err != nil {
                return err
             }
            textSubjectCodeQualifierReceived = true
        }
    }
    // check if textSubjectCodeQualifier (a required property) was received
    if !textSubjectCodeQualifierReceived {
        return errors.New("\"textSubjectCodeQualifier\" is required but was not present")
    }
    return nil
}

func (strct *GRP11) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "freightCharge" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"freightCharge\": ")
	if tmp, err := json.Marshal(strct.FreightCharge); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "insuranceChargesCustoms" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"insuranceChargesCustoms\": ")
	if tmp, err := json.Marshal(strct.InsuranceChargesCustoms); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "InvoiceTotalAmount" field is required
    if strct.InvoiceTotalAmount == nil {
        return nil, errors.New("invoiceTotalAmount is a required field")
    }
    // Marshal the "invoiceTotalAmount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"invoiceTotalAmount\": ")
	if tmp, err := json.Marshal(strct.InvoiceTotalAmount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "otherDeductibleCharges" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"otherDeductibleCharges\": ")
	if tmp, err := json.Marshal(strct.OtherDeductibleCharges); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "otherValuationChargesCustoms" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"otherValuationChargesCustoms\": ")
	if tmp, err := json.Marshal(strct.OtherValuationChargesCustoms); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "transportChargesCustoms" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"transportChargesCustoms\": ")
	if tmp, err := json.Marshal(strct.TransportChargesCustoms); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GRP11) UnmarshalJSON(b []byte) error {
    invoiceTotalAmountReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "freightCharge":
            if err := json.Unmarshal([]byte(v), &strct.FreightCharge); err != nil {
                return err
             }
        case "insuranceChargesCustoms":
            if err := json.Unmarshal([]byte(v), &strct.InsuranceChargesCustoms); err != nil {
                return err
             }
        case "invoiceTotalAmount":
            if err := json.Unmarshal([]byte(v), &strct.InvoiceTotalAmount); err != nil {
                return err
             }
            invoiceTotalAmountReceived = true
        case "otherDeductibleCharges":
            if err := json.Unmarshal([]byte(v), &strct.OtherDeductibleCharges); err != nil {
                return err
             }
        case "otherValuationChargesCustoms":
            if err := json.Unmarshal([]byte(v), &strct.OtherValuationChargesCustoms); err != nil {
                return err
             }
        case "transportChargesCustoms":
            if err := json.Unmarshal([]byte(v), &strct.TransportChargesCustoms); err != nil {
                return err
             }
        }
    }
    // check if invoiceTotalAmount (a required property) was received
    if !invoiceTotalAmountReceived {
        return errors.New("\"invoiceTotalAmount\" is required but was not present")
    }
    return nil
}

func (strct *GRP11Items) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DutyTaxOrFeeAmount" field is required
    if strct.DutyTaxOrFeeAmount == nil {
        return nil, errors.New("dutyTaxOrFeeAmount is a required field")
    }
    // Marshal the "dutyTaxOrFeeAmount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"dutyTaxOrFeeAmount\": ")
	if tmp, err := json.Marshal(strct.DutyTaxOrFeeAmount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "totalOfEachDutyTaxOrFeeTypeCustomsDeclaration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"totalOfEachDutyTaxOrFeeTypeCustomsDeclaration\": ")
	if tmp, err := json.Marshal(strct.TotalOfEachDutyTaxOrFeeTypeCustomsDeclaration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GRP11Items) UnmarshalJSON(b []byte) error {
    dutyTaxOrFeeAmountReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "dutyTaxOrFeeAmount":
            if err := json.Unmarshal([]byte(v), &strct.DutyTaxOrFeeAmount); err != nil {
                return err
             }
            dutyTaxOrFeeAmountReceived = true
        case "totalOfEachDutyTaxOrFeeTypeCustomsDeclaration":
            if err := json.Unmarshal([]byte(v), &strct.TotalOfEachDutyTaxOrFeeTypeCustomsDeclaration); err != nil {
                return err
             }
        }
    }
    // check if dutyTaxOrFeeAmount (a required property) was received
    if !dutyTaxOrFeeAmountReceived {
        return errors.New("\"dutyTaxOrFeeAmount\" is required but was not present")
    }
    return nil
}

func (strct *GRP30Items) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "accountingDataAdjustmentCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"accountingDataAdjustmentCode\": ")
	if tmp, err := json.Marshal(strct.AccountingDataAdjustmentCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "accountingDataMethodCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"accountingDataMethodCode\": ")
	if tmp, err := json.Marshal(strct.AccountingDataMethodCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "additionalInformationItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"additionalInformationItems\": ")
	if tmp, err := json.Marshal(strct.AdditionalInformationItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "consignee" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"consignee\": ")
	if tmp, err := json.Marshal(strct.Consignee); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "consignor" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"consignor\": ")
	if tmp, err := json.Marshal(strct.Consignor); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "countryOfOrigin" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"countryOfOrigin\": ")
	if tmp, err := json.Marshal(strct.CountryOfOrigin); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "countryOfTransitItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"countryOfTransitItems\": ")
	if tmp, err := json.Marshal(strct.CountryOfTransitItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "customs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"customs\": ")
	if tmp, err := json.Marshal(strct.Customs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "customsStatusOfGoods" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"customsStatusOfGoods\": ")
	if tmp, err := json.Marshal(strct.CustomsStatusOfGoods); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "dimensionsTotalWeight" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"dimensionsTotalWeight\": ")
	if tmp, err := json.Marshal(strct.DimensionsTotalWeight); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "grp31" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"grp31\": ")
	if tmp, err := json.Marshal(strct.Grp31); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "grp33" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"grp33\": ")
	if tmp, err := json.Marshal(strct.Grp33); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "grp41" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"grp41\": ")
	if tmp, err := json.Marshal(strct.Grp41); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "i1stSpecifiedTariffQuantity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"i1stSpecifiedTariffQuantity\": ")
	if tmp, err := json.Marshal(strct.I1stSpecifiedTariffQuantity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "i2ndSpecifiedTariffQuantity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"i2ndSpecifiedTariffQuantity\": ")
	if tmp, err := json.Marshal(strct.I2ndSpecifiedTariffQuantity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "i3rdSpecifiedTariffQuantity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"i3rdSpecifiedTariffQuantity\": ")
	if tmp, err := json.Marshal(strct.I3rdSpecifiedTariffQuantity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ItemDetailsAndReference" field is required
    if strct.ItemDetailsAndReference == nil {
        return nil, errors.New("itemDetailsAndReference is a required field")
    }
    // Marshal the "itemDetailsAndReference" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"itemDetailsAndReference\": ")
	if tmp, err := json.Marshal(strct.ItemDetailsAndReference); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "otherAccountingCodes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"otherAccountingCodes\": ")
	if tmp, err := json.Marshal(strct.OtherAccountingCodes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "previousCustomsDocuments" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"previousCustomsDocuments\": ")
	if tmp, err := json.Marshal(strct.PreviousCustomsDocuments); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "quotaNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"quotaNumber\": ")
	if tmp, err := json.Marshal(strct.QuotaNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "relatedDocuments" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"relatedDocuments\": ")
	if tmp, err := json.Marshal(strct.RelatedDocuments); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "unitLoadDeviceEGContainerIdentificationNumberItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"unitLoadDeviceEGContainerIdentificationNumberItems\": ")
	if tmp, err := json.Marshal(strct.UnitLoadDeviceEGContainerIdentificationNumberItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "unitedNationsDangerousGoodsUndgNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"unitedNationsDangerousGoodsUndgNumber\": ")
	if tmp, err := json.Marshal(strct.UnitedNationsDangerousGoodsUndgNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GRP30Items) UnmarshalJSON(b []byte) error {
    itemDetailsAndReferenceReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "accountingDataAdjustmentCode":
            if err := json.Unmarshal([]byte(v), &strct.AccountingDataAdjustmentCode); err != nil {
                return err
             }
        case "accountingDataMethodCode":
            if err := json.Unmarshal([]byte(v), &strct.AccountingDataMethodCode); err != nil {
                return err
             }
        case "additionalInformationItems":
            if err := json.Unmarshal([]byte(v), &strct.AdditionalInformationItems); err != nil {
                return err
             }
        case "consignee":
            if err := json.Unmarshal([]byte(v), &strct.Consignee); err != nil {
                return err
             }
        case "consignor":
            if err := json.Unmarshal([]byte(v), &strct.Consignor); err != nil {
                return err
             }
        case "countryOfOrigin":
            if err := json.Unmarshal([]byte(v), &strct.CountryOfOrigin); err != nil {
                return err
             }
        case "countryOfTransitItems":
            if err := json.Unmarshal([]byte(v), &strct.CountryOfTransitItems); err != nil {
                return err
             }
        case "customs":
            if err := json.Unmarshal([]byte(v), &strct.Customs); err != nil {
                return err
             }
        case "customsStatusOfGoods":
            if err := json.Unmarshal([]byte(v), &strct.CustomsStatusOfGoods); err != nil {
                return err
             }
        case "dimensionsTotalWeight":
            if err := json.Unmarshal([]byte(v), &strct.DimensionsTotalWeight); err != nil {
                return err
             }
        case "grp31":
            if err := json.Unmarshal([]byte(v), &strct.Grp31); err != nil {
                return err
             }
        case "grp33":
            if err := json.Unmarshal([]byte(v), &strct.Grp33); err != nil {
                return err
             }
        case "grp41":
            if err := json.Unmarshal([]byte(v), &strct.Grp41); err != nil {
                return err
             }
        case "i1stSpecifiedTariffQuantity":
            if err := json.Unmarshal([]byte(v), &strct.I1stSpecifiedTariffQuantity); err != nil {
                return err
             }
        case "i2ndSpecifiedTariffQuantity":
            if err := json.Unmarshal([]byte(v), &strct.I2ndSpecifiedTariffQuantity); err != nil {
                return err
             }
        case "i3rdSpecifiedTariffQuantity":
            if err := json.Unmarshal([]byte(v), &strct.I3rdSpecifiedTariffQuantity); err != nil {
                return err
             }
        case "itemDetailsAndReference":
            if err := json.Unmarshal([]byte(v), &strct.ItemDetailsAndReference); err != nil {
                return err
             }
            itemDetailsAndReferenceReceived = true
        case "otherAccountingCodes":
            if err := json.Unmarshal([]byte(v), &strct.OtherAccountingCodes); err != nil {
                return err
             }
        case "previousCustomsDocuments":
            if err := json.Unmarshal([]byte(v), &strct.PreviousCustomsDocuments); err != nil {
                return err
             }
        case "quotaNumber":
            if err := json.Unmarshal([]byte(v), &strct.QuotaNumber); err != nil {
                return err
             }
        case "relatedDocuments":
            if err := json.Unmarshal([]byte(v), &strct.RelatedDocuments); err != nil {
                return err
             }
        case "unitLoadDeviceEGContainerIdentificationNumberItems":
            if err := json.Unmarshal([]byte(v), &strct.UnitLoadDeviceEGContainerIdentificationNumberItems); err != nil {
                return err
             }
        case "unitedNationsDangerousGoodsUndgNumber":
            if err := json.Unmarshal([]byte(v), &strct.UnitedNationsDangerousGoodsUndgNumber); err != nil {
                return err
             }
        }
    }
    // check if itemDetailsAndReference (a required property) was received
    if !itemDetailsAndReferenceReceived {
        return errors.New("\"itemDetailsAndReference\" is required but was not present")
    }
    return nil
}

func (strct *GRP36) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ItemDescription" field is required
    if strct.ItemDescription == nil {
        return nil, errors.New("itemDescription is a required field")
    }
    // Marshal the "itemDescription" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"itemDescription\": ")
	if tmp, err := json.Marshal(strct.ItemDescription); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GRP36) UnmarshalJSON(b []byte) error {
    itemDescriptionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "itemDescription":
            if err := json.Unmarshal([]byte(v), &strct.ItemDescription); err != nil {
                return err
             }
            itemDescriptionReceived = true
        }
    }
    // check if itemDescription (a required property) was received
    if !itemDescriptionReceived {
        return errors.New("\"itemDescription\" is required but was not present")
    }
    return nil
}

func (strct *GRP4) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AtDestination" field is required
    if strct.AtDestination == nil {
        return nil, errors.New("atDestination is a required field")
    }
    // Marshal the "atDestination" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"atDestination\": ")
	if tmp, err := json.Marshal(strct.AtDestination); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "inlandTransport" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"inlandTransport\": ")
	if tmp, err := json.Marshal(strct.InlandTransport); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GRP4) UnmarshalJSON(b []byte) error {
    atDestinationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "atDestination":
            if err := json.Unmarshal([]byte(v), &strct.AtDestination); err != nil {
                return err
             }
            atDestinationReceived = true
        case "inlandTransport":
            if err := json.Unmarshal([]byte(v), &strct.InlandTransport); err != nil {
                return err
             }
        }
    }
    // check if atDestination (a required property) was received
    if !atDestinationReceived {
        return errors.New("\"atDestination\" is required but was not present")
    }
    return nil
}

func (strct *GroupResponses) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ActionCoded" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "actionCoded" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"actionCoded\": ")
	if tmp, err := json.Marshal(strct.ActionCoded); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "applicationRecipientIdentification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"applicationRecipientIdentification\": ")
	if tmp, err := json.Marshal(strct.ApplicationRecipientIdentification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "applicationSenderIdentification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"applicationSenderIdentification\": ")
	if tmp, err := json.Marshal(strct.ApplicationSenderIdentification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "dataElementIdentification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"dataElementIdentification\": ")
	if tmp, err := json.Marshal(strct.DataElementIdentification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "GroupReferenceNumber" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "groupReferenceNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"groupReferenceNumber\": ")
	if tmp, err := json.Marshal(strct.GroupReferenceNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "securityReferenceNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"securityReferenceNumber\": ")
	if tmp, err := json.Marshal(strct.SecurityReferenceNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "securitySegmentPosition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"securitySegmentPosition\": ")
	if tmp, err := json.Marshal(strct.SecuritySegmentPosition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "serviceSegmentTagCoded" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"serviceSegmentTagCoded\": ")
	if tmp, err := json.Marshal(strct.ServiceSegmentTagCoded); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "syntaxErrorCoded" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"syntaxErrorCoded\": ")
	if tmp, err := json.Marshal(strct.SyntaxErrorCoded); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GroupResponses) UnmarshalJSON(b []byte) error {
    actionCodedReceived := false
    groupReferenceNumberReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "actionCoded":
            if err := json.Unmarshal([]byte(v), &strct.ActionCoded); err != nil {
                return err
             }
            actionCodedReceived = true
        case "applicationRecipientIdentification":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationRecipientIdentification); err != nil {
                return err
             }
        case "applicationSenderIdentification":
            if err := json.Unmarshal([]byte(v), &strct.ApplicationSenderIdentification); err != nil {
                return err
             }
        case "dataElementIdentification":
            if err := json.Unmarshal([]byte(v), &strct.DataElementIdentification); err != nil {
                return err
             }
        case "groupReferenceNumber":
            if err := json.Unmarshal([]byte(v), &strct.GroupReferenceNumber); err != nil {
                return err
             }
            groupReferenceNumberReceived = true
        case "securityReferenceNumber":
            if err := json.Unmarshal([]byte(v), &strct.SecurityReferenceNumber); err != nil {
                return err
             }
        case "securitySegmentPosition":
            if err := json.Unmarshal([]byte(v), &strct.SecuritySegmentPosition); err != nil {
                return err
             }
        case "serviceSegmentTagCoded":
            if err := json.Unmarshal([]byte(v), &strct.ServiceSegmentTagCoded); err != nil {
                return err
             }
        case "syntaxErrorCoded":
            if err := json.Unmarshal([]byte(v), &strct.SyntaxErrorCoded); err != nil {
                return err
             }
        }
    }
    // check if actionCoded (a required property) was received
    if !actionCodedReceived {
        return errors.New("\"actionCoded\" is required but was not present")
    }
    // check if groupReferenceNumber (a required property) was received
    if !groupReferenceNumberReceived {
        return errors.New("\"groupReferenceNumber\" is required but was not present")
    }
    return nil
}

func (strct *INTERCHANGERECIPIENT) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "identificationCodeQualifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"identificationCodeQualifier\": ")
	if tmp, err := json.Marshal(strct.IdentificationCodeQualifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "InterchangeRecipientIdentification" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "interchangeRecipientIdentification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"interchangeRecipientIdentification\": ")
	if tmp, err := json.Marshal(strct.InterchangeRecipientIdentification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "interchangeRecipientInternalIdentification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"interchangeRecipientInternalIdentification\": ")
	if tmp, err := json.Marshal(strct.InterchangeRecipientInternalIdentification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "interchangeRecipientInternalSubIdentification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"interchangeRecipientInternalSubIdentification\": ")
	if tmp, err := json.Marshal(strct.InterchangeRecipientInternalSubIdentification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *INTERCHANGERECIPIENT) UnmarshalJSON(b []byte) error {
    interchangeRecipientIdentificationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "identificationCodeQualifier":
            if err := json.Unmarshal([]byte(v), &strct.IdentificationCodeQualifier); err != nil {
                return err
             }
        case "interchangeRecipientIdentification":
            if err := json.Unmarshal([]byte(v), &strct.InterchangeRecipientIdentification); err != nil {
                return err
             }
            interchangeRecipientIdentificationReceived = true
        case "interchangeRecipientInternalIdentification":
            if err := json.Unmarshal([]byte(v), &strct.InterchangeRecipientInternalIdentification); err != nil {
                return err
             }
        case "interchangeRecipientInternalSubIdentification":
            if err := json.Unmarshal([]byte(v), &strct.InterchangeRecipientInternalSubIdentification); err != nil {
                return err
             }
        }
    }
    // check if interchangeRecipientIdentification (a required property) was received
    if !interchangeRecipientIdentificationReceived {
        return errors.New("\"interchangeRecipientIdentification\" is required but was not present")
    }
    return nil
}

func (strct *INTERCHANGESENDER) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "identificationCodeQualifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"identificationCodeQualifier\": ")
	if tmp, err := json.Marshal(strct.IdentificationCodeQualifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "InterchangeSenderIdentification" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "interchangeSenderIdentification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"interchangeSenderIdentification\": ")
	if tmp, err := json.Marshal(strct.InterchangeSenderIdentification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "interchangeSenderInternalIdentification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"interchangeSenderInternalIdentification\": ")
	if tmp, err := json.Marshal(strct.InterchangeSenderInternalIdentification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "interchangeSenderInternalSubIdentification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"interchangeSenderInternalSubIdentification\": ")
	if tmp, err := json.Marshal(strct.InterchangeSenderInternalSubIdentification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *INTERCHANGESENDER) UnmarshalJSON(b []byte) error {
    interchangeSenderIdentificationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "identificationCodeQualifier":
            if err := json.Unmarshal([]byte(v), &strct.IdentificationCodeQualifier); err != nil {
                return err
             }
        case "interchangeSenderIdentification":
            if err := json.Unmarshal([]byte(v), &strct.InterchangeSenderIdentification); err != nil {
                return err
             }
            interchangeSenderIdentificationReceived = true
        case "interchangeSenderInternalIdentification":
            if err := json.Unmarshal([]byte(v), &strct.InterchangeSenderInternalIdentification); err != nil {
                return err
             }
        case "interchangeSenderInternalSubIdentification":
            if err := json.Unmarshal([]byte(v), &strct.InterchangeSenderInternalSubIdentification); err != nil {
                return err
             }
        }
    }
    // check if interchangeSenderIdentification (a required property) was received
    if !interchangeSenderIdentificationReceived {
        return errors.New("\"interchangeSenderIdentification\" is required but was not present")
    }
    return nil
}

func (strct *InterchangeResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "actionCoded" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"actionCoded\": ")
	if tmp, err := json.Marshal(strct.ActionCoded); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "dataElementIdentification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"dataElementIdentification\": ")
	if tmp, err := json.Marshal(strct.DataElementIdentification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "InterchangeControlReference" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "interchangeControlReference" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"interchangeControlReference\": ")
	if tmp, err := json.Marshal(strct.InterchangeControlReference); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "interchangeRecipient" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"interchangeRecipient\": ")
	if tmp, err := json.Marshal(strct.InterchangeRecipient); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "interchangeSender" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"interchangeSender\": ")
	if tmp, err := json.Marshal(strct.InterchangeSender); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "securityReferenceNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"securityReferenceNumber\": ")
	if tmp, err := json.Marshal(strct.SecurityReferenceNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "securitySegmentPosition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"securitySegmentPosition\": ")
	if tmp, err := json.Marshal(strct.SecuritySegmentPosition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "serviceSegmentTagCoded" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"serviceSegmentTagCoded\": ")
	if tmp, err := json.Marshal(strct.ServiceSegmentTagCoded); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "syntaxErrorCoded" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"syntaxErrorCoded\": ")
	if tmp, err := json.Marshal(strct.SyntaxErrorCoded); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InterchangeResponse) UnmarshalJSON(b []byte) error {
    interchangeControlReferenceReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "actionCoded":
            if err := json.Unmarshal([]byte(v), &strct.ActionCoded); err != nil {
                return err
             }
        case "dataElementIdentification":
            if err := json.Unmarshal([]byte(v), &strct.DataElementIdentification); err != nil {
                return err
             }
        case "interchangeControlReference":
            if err := json.Unmarshal([]byte(v), &strct.InterchangeControlReference); err != nil {
                return err
             }
            interchangeControlReferenceReceived = true
        case "interchangeRecipient":
            if err := json.Unmarshal([]byte(v), &strct.InterchangeRecipient); err != nil {
                return err
             }
        case "interchangeSender":
            if err := json.Unmarshal([]byte(v), &strct.InterchangeSender); err != nil {
                return err
             }
        case "securityReferenceNumber":
            if err := json.Unmarshal([]byte(v), &strct.SecurityReferenceNumber); err != nil {
                return err
             }
        case "securitySegmentPosition":
            if err := json.Unmarshal([]byte(v), &strct.SecuritySegmentPosition); err != nil {
                return err
             }
        case "serviceSegmentTagCoded":
            if err := json.Unmarshal([]byte(v), &strct.ServiceSegmentTagCoded); err != nil {
                return err
             }
        case "syntaxErrorCoded":
            if err := json.Unmarshal([]byte(v), &strct.SyntaxErrorCoded); err != nil {
                return err
             }
        }
    }
    // check if interchangeControlReference (a required property) was received
    if !interchangeControlReferenceReceived {
        return errors.New("\"interchangeControlReference\" is required but was not present")
    }
    return nil
}

func (strct *LOCATIONIDENTIFICATION) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "codeListIdentificationCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"codeListIdentificationCode\": ")
	if tmp, err := json.Marshal(strct.CodeListIdentificationCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "codeListResponsibleAgencyCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"codeListResponsibleAgencyCode\": ")
	if tmp, err := json.Marshal(strct.CodeListResponsibleAgencyCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LocationNameCode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "locationNameCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"locationNameCode\": ")
	if tmp, err := json.Marshal(strct.LocationNameCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LOCATIONIDENTIFICATION) UnmarshalJSON(b []byte) error {
    locationNameCodeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "codeListIdentificationCode":
            if err := json.Unmarshal([]byte(v), &strct.CodeListIdentificationCode); err != nil {
                return err
             }
        case "codeListResponsibleAgencyCode":
            if err := json.Unmarshal([]byte(v), &strct.CodeListResponsibleAgencyCode); err != nil {
                return err
             }
        case "locationNameCode":
            if err := json.Unmarshal([]byte(v), &strct.LocationNameCode); err != nil {
                return err
             }
            locationNameCodeReceived = true
        }
    }
    // check if locationNameCode (a required property) was received
    if !locationNameCodeReceived {
        return errors.New("\"locationNameCode\" is required but was not present")
    }
    return nil
}

func (strct *MESSAGEIMPLEMENTATIONGUIDELINEIDENTIFICATION) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "controllingAgencyCoded" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"controllingAgencyCoded\": ")
	if tmp, err := json.Marshal(strct.ControllingAgencyCoded); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MessageImplementationGuidelineIdentification" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "messageImplementationGuidelineIdentification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"messageImplementationGuidelineIdentification\": ")
	if tmp, err := json.Marshal(strct.MessageImplementationGuidelineIdentification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "messageImplementationGuidelineReleaseNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"messageImplementationGuidelineReleaseNumber\": ")
	if tmp, err := json.Marshal(strct.MessageImplementationGuidelineReleaseNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "messageImplementationGuidelineVersionNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"messageImplementationGuidelineVersionNumber\": ")
	if tmp, err := json.Marshal(strct.MessageImplementationGuidelineVersionNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MESSAGEIMPLEMENTATIONGUIDELINEIDENTIFICATION) UnmarshalJSON(b []byte) error {
    messageImplementationGuidelineIdentificationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "controllingAgencyCoded":
            if err := json.Unmarshal([]byte(v), &strct.ControllingAgencyCoded); err != nil {
                return err
             }
        case "messageImplementationGuidelineIdentification":
            if err := json.Unmarshal([]byte(v), &strct.MessageImplementationGuidelineIdentification); err != nil {
                return err
             }
            messageImplementationGuidelineIdentificationReceived = true
        case "messageImplementationGuidelineReleaseNumber":
            if err := json.Unmarshal([]byte(v), &strct.MessageImplementationGuidelineReleaseNumber); err != nil {
                return err
             }
        case "messageImplementationGuidelineVersionNumber":
            if err := json.Unmarshal([]byte(v), &strct.MessageImplementationGuidelineVersionNumber); err != nil {
                return err
             }
        }
    }
    // check if messageImplementationGuidelineIdentification (a required property) was received
    if !messageImplementationGuidelineIdentificationReceived {
        return errors.New("\"messageImplementationGuidelineIdentification\" is required but was not present")
    }
    return nil
}

func (strct *MESSAGESUBSETIDENTIFICATION) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "controllingAgencyCoded" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"controllingAgencyCoded\": ")
	if tmp, err := json.Marshal(strct.ControllingAgencyCoded); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MessageSubsetIdentification" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "messageSubsetIdentification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"messageSubsetIdentification\": ")
	if tmp, err := json.Marshal(strct.MessageSubsetIdentification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "messageSubsetReleaseNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"messageSubsetReleaseNumber\": ")
	if tmp, err := json.Marshal(strct.MessageSubsetReleaseNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "messageSubsetVersionNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"messageSubsetVersionNumber\": ")
	if tmp, err := json.Marshal(strct.MessageSubsetVersionNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MESSAGESUBSETIDENTIFICATION) UnmarshalJSON(b []byte) error {
    messageSubsetIdentificationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "controllingAgencyCoded":
            if err := json.Unmarshal([]byte(v), &strct.ControllingAgencyCoded); err != nil {
                return err
             }
        case "messageSubsetIdentification":
            if err := json.Unmarshal([]byte(v), &strct.MessageSubsetIdentification); err != nil {
                return err
             }
            messageSubsetIdentificationReceived = true
        case "messageSubsetReleaseNumber":
            if err := json.Unmarshal([]byte(v), &strct.MessageSubsetReleaseNumber); err != nil {
                return err
             }
        case "messageSubsetVersionNumber":
            if err := json.Unmarshal([]byte(v), &strct.MessageSubsetVersionNumber); err != nil {
                return err
             }
        }
    }
    // check if messageSubsetIdentification (a required property) was received
    if !messageSubsetIdentificationReceived {
        return errors.New("\"messageSubsetIdentification\" is required but was not present")
    }
    return nil
}

func (strct *MessageLevelActionAndErrorCodes) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ActionCoded" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "actionCoded" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"actionCoded\": ")
	if tmp, err := json.Marshal(strct.ActionCoded); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "syntaxErrorCoded" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"syntaxErrorCoded\": ")
	if tmp, err := json.Marshal(strct.SyntaxErrorCoded); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MessageLevelActionAndErrorCodes) UnmarshalJSON(b []byte) error {
    actionCodedReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "actionCoded":
            if err := json.Unmarshal([]byte(v), &strct.ActionCoded); err != nil {
                return err
             }
            actionCodedReceived = true
        case "syntaxErrorCoded":
            if err := json.Unmarshal([]byte(v), &strct.SyntaxErrorCoded); err != nil {
                return err
             }
        }
    }
    // check if actionCoded (a required property) was received
    if !actionCodedReceived {
        return errors.New("\"actionCoded\" is required but was not present")
    }
    return nil
}

func (strct *MessagePackageResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "actionCoded" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"actionCoded\": ")
	if tmp, err := json.Marshal(strct.ActionCoded); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "dataElementIdentification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"dataElementIdentification\": ")
	if tmp, err := json.Marshal(strct.DataElementIdentification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "messageIdentifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"messageIdentifier\": ")
	if tmp, err := json.Marshal(strct.MessageIdentifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MessageReferenceNumber" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "messageReferenceNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"messageReferenceNumber\": ")
	if tmp, err := json.Marshal(strct.MessageReferenceNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "packageReferenceNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"packageReferenceNumber\": ")
	if tmp, err := json.Marshal(strct.PackageReferenceNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "referenceIdentification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"referenceIdentification\": ")
	if tmp, err := json.Marshal(strct.ReferenceIdentification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "securityReferenceNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"securityReferenceNumber\": ")
	if tmp, err := json.Marshal(strct.SecurityReferenceNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "securitySegmentPosition" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"securitySegmentPosition\": ")
	if tmp, err := json.Marshal(strct.SecuritySegmentPosition); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "serviceSegmentTagCoded" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"serviceSegmentTagCoded\": ")
	if tmp, err := json.Marshal(strct.ServiceSegmentTagCoded); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "syntaxErrorCoded" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"syntaxErrorCoded\": ")
	if tmp, err := json.Marshal(strct.SyntaxErrorCoded); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MessagePackageResponse) UnmarshalJSON(b []byte) error {
    messageReferenceNumberReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "actionCoded":
            if err := json.Unmarshal([]byte(v), &strct.ActionCoded); err != nil {
                return err
             }
        case "dataElementIdentification":
            if err := json.Unmarshal([]byte(v), &strct.DataElementIdentification); err != nil {
                return err
             }
        case "messageIdentifier":
            if err := json.Unmarshal([]byte(v), &strct.MessageIdentifier); err != nil {
                return err
             }
        case "messageReferenceNumber":
            if err := json.Unmarshal([]byte(v), &strct.MessageReferenceNumber); err != nil {
                return err
             }
            messageReferenceNumberReceived = true
        case "packageReferenceNumber":
            if err := json.Unmarshal([]byte(v), &strct.PackageReferenceNumber); err != nil {
                return err
             }
        case "referenceIdentification":
            if err := json.Unmarshal([]byte(v), &strct.ReferenceIdentification); err != nil {
                return err
             }
        case "securityReferenceNumber":
            if err := json.Unmarshal([]byte(v), &strct.SecurityReferenceNumber); err != nil {
                return err
             }
        case "securitySegmentPosition":
            if err := json.Unmarshal([]byte(v), &strct.SecuritySegmentPosition); err != nil {
                return err
             }
        case "serviceSegmentTagCoded":
            if err := json.Unmarshal([]byte(v), &strct.ServiceSegmentTagCoded); err != nil {
                return err
             }
        case "syntaxErrorCoded":
            if err := json.Unmarshal([]byte(v), &strct.SyntaxErrorCoded); err != nil {
                return err
             }
        }
    }
    // check if messageReferenceNumber (a required property) was received
    if !messageReferenceNumberReceived {
        return errors.New("\"messageReferenceNumber\" is required but was not present")
    }
    return nil
}

func (strct *NAMEANDADDRESS) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "NameAndAddressDescription1" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "nameAndAddressDescription_1" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"nameAndAddressDescription_1\": ")
	if tmp, err := json.Marshal(strct.NameAndAddressDescription1); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "nameAndAddressDescription_2" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"nameAndAddressDescription_2\": ")
	if tmp, err := json.Marshal(strct.NameAndAddressDescription2); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "nameAndAddressDescription_3" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"nameAndAddressDescription_3\": ")
	if tmp, err := json.Marshal(strct.NameAndAddressDescription3); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "nameAndAddressDescription_4" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"nameAndAddressDescription_4\": ")
	if tmp, err := json.Marshal(strct.NameAndAddressDescription4); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "nameAndAddressDescription_5" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"nameAndAddressDescription_5\": ")
	if tmp, err := json.Marshal(strct.NameAndAddressDescription5); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NAMEANDADDRESS) UnmarshalJSON(b []byte) error {
    nameAndAddressDescription_1Received := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "nameAndAddressDescription_1":
            if err := json.Unmarshal([]byte(v), &strct.NameAndAddressDescription1); err != nil {
                return err
             }
            nameAndAddressDescription_1Received = true
        case "nameAndAddressDescription_2":
            if err := json.Unmarshal([]byte(v), &strct.NameAndAddressDescription2); err != nil {
                return err
             }
        case "nameAndAddressDescription_3":
            if err := json.Unmarshal([]byte(v), &strct.NameAndAddressDescription3); err != nil {
                return err
             }
        case "nameAndAddressDescription_4":
            if err := json.Unmarshal([]byte(v), &strct.NameAndAddressDescription4); err != nil {
                return err
             }
        case "nameAndAddressDescription_5":
            if err := json.Unmarshal([]byte(v), &strct.NameAndAddressDescription5); err != nil {
                return err
             }
        }
    }
    // check if nameAndAddressDescription_1 (a required property) was received
    if !nameAndAddressDescription_1Received {
        return errors.New("\"nameAndAddressDescription_1\" is required but was not present")
    }
    return nil
}

func (strct *PACKAGETYPE) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "PackageTypeDescriptionCode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "packageTypeDescriptionCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"packageTypeDescriptionCode\": ")
	if tmp, err := json.Marshal(strct.PackageTypeDescriptionCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PACKAGETYPE) UnmarshalJSON(b []byte) error {
    packageTypeDescriptionCodeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "packageTypeDescriptionCode":
            if err := json.Unmarshal([]byte(v), &strct.PackageTypeDescriptionCode); err != nil {
                return err
             }
            packageTypeDescriptionCodeReceived = true
        }
    }
    // check if packageTypeDescriptionCode (a required property) was received
    if !packageTypeDescriptionCodeReceived {
        return errors.New("\"packageTypeDescriptionCode\" is required but was not present")
    }
    return nil
}

func (strct *PARTYIDENTIFICATIONDETAILS) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "codeListIdentificationCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"codeListIdentificationCode\": ")
	if tmp, err := json.Marshal(strct.CodeListIdentificationCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "codeListResponsibleAgencyCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"codeListResponsibleAgencyCode\": ")
	if tmp, err := json.Marshal(strct.CodeListResponsibleAgencyCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PartyIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "partyIdentifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"partyIdentifier\": ")
	if tmp, err := json.Marshal(strct.PartyIdentifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PARTYIDENTIFICATIONDETAILS) UnmarshalJSON(b []byte) error {
    partyIdentifierReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "codeListIdentificationCode":
            if err := json.Unmarshal([]byte(v), &strct.CodeListIdentificationCode); err != nil {
                return err
             }
        case "codeListResponsibleAgencyCode":
            if err := json.Unmarshal([]byte(v), &strct.CodeListResponsibleAgencyCode); err != nil {
                return err
             }
        case "partyIdentifier":
            if err := json.Unmarshal([]byte(v), &strct.PartyIdentifier); err != nil {
                return err
             }
            partyIdentifierReceived = true
        }
    }
    // check if partyIdentifier (a required property) was received
    if !partyIdentifierReceived {
        return errors.New("\"partyIdentifier\" is required but was not present")
    }
    return nil
}

func (strct *PARTYNAME) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "PartyName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "partyName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"partyName\": ")
	if tmp, err := json.Marshal(strct.PartyName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PARTYNAME) UnmarshalJSON(b []byte) error {
    partyNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "partyName":
            if err := json.Unmarshal([]byte(v), &strct.PartyName); err != nil {
                return err
             }
            partyNameReceived = true
        }
    }
    // check if partyName (a required property) was received
    if !partyNameReceived {
        return errors.New("\"partyName\" is required but was not present")
    }
    return nil
}

func (strct *Product) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ProductId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "productId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"productId\": ")
	if tmp, err := json.Marshal(strct.ProductId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Product) UnmarshalJSON(b []byte) error {
    productIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "productId":
            if err := json.Unmarshal([]byte(v), &strct.ProductId); err != nil {
                return err
             }
            productIdReceived = true
        }
    }
    // check if productId (a required property) was received
    if !productIdReceived {
        return errors.New("\"productId\" is required but was not present")
    }
    return nil
}

func (strct *REFERENCEIDENTIFICATION) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ReferenceIdentificationNumber" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "referenceIdentificationNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"referenceIdentificationNumber\": ")
	if tmp, err := json.Marshal(strct.ReferenceIdentificationNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ReferenceQualifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "referenceQualifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"referenceQualifier\": ")
	if tmp, err := json.Marshal(strct.ReferenceQualifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *REFERENCEIDENTIFICATION) UnmarshalJSON(b []byte) error {
    referenceIdentificationNumberReceived := false
    referenceQualifierReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "referenceIdentificationNumber":
            if err := json.Unmarshal([]byte(v), &strct.ReferenceIdentificationNumber); err != nil {
                return err
             }
            referenceIdentificationNumberReceived = true
        case "referenceQualifier":
            if err := json.Unmarshal([]byte(v), &strct.ReferenceQualifier); err != nil {
                return err
             }
            referenceQualifierReceived = true
        }
    }
    // check if referenceIdentificationNumber (a required property) was received
    if !referenceIdentificationNumberReceived {
        return errors.New("\"referenceIdentificationNumber\" is required but was not present")
    }
    // check if referenceQualifier (a required property) was received
    if !referenceQualifierReceived {
        return errors.New("\"referenceQualifier\" is required but was not present")
    }
    return nil
}

func (strct *SCENARIOIDENTIFICATION) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "controllingAgencyCoded" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"controllingAgencyCoded\": ")
	if tmp, err := json.Marshal(strct.ControllingAgencyCoded); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ScenarioIdentification" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "scenarioIdentification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"scenarioIdentification\": ")
	if tmp, err := json.Marshal(strct.ScenarioIdentification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "scenarioReleaseNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"scenarioReleaseNumber\": ")
	if tmp, err := json.Marshal(strct.ScenarioReleaseNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "scenarioVersionNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"scenarioVersionNumber\": ")
	if tmp, err := json.Marshal(strct.ScenarioVersionNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SCENARIOIDENTIFICATION) UnmarshalJSON(b []byte) error {
    scenarioIdentificationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "controllingAgencyCoded":
            if err := json.Unmarshal([]byte(v), &strct.ControllingAgencyCoded); err != nil {
                return err
             }
        case "scenarioIdentification":
            if err := json.Unmarshal([]byte(v), &strct.ScenarioIdentification); err != nil {
                return err
             }
            scenarioIdentificationReceived = true
        case "scenarioReleaseNumber":
            if err := json.Unmarshal([]byte(v), &strct.ScenarioReleaseNumber); err != nil {
                return err
             }
        case "scenarioVersionNumber":
            if err := json.Unmarshal([]byte(v), &strct.ScenarioVersionNumber); err != nil {
                return err
             }
        }
    }
    // check if scenarioIdentification (a required property) was received
    if !scenarioIdentificationReceived {
        return errors.New("\"scenarioIdentification\" is required but was not present")
    }
    return nil
}

func (strct *STATUSOFTHETRANSFER) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "firstAndLastTransfer" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"firstAndLastTransfer\": ")
	if tmp, err := json.Marshal(strct.FirstAndLastTransfer); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SequenceOfTransfers" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "sequenceOfTransfers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"sequenceOfTransfers\": ")
	if tmp, err := json.Marshal(strct.SequenceOfTransfers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *STATUSOFTHETRANSFER) UnmarshalJSON(b []byte) error {
    sequenceOfTransfersReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "firstAndLastTransfer":
            if err := json.Unmarshal([]byte(v), &strct.FirstAndLastTransfer); err != nil {
                return err
             }
        case "sequenceOfTransfers":
            if err := json.Unmarshal([]byte(v), &strct.SequenceOfTransfers); err != nil {
                return err
             }
            sequenceOfTransfersReceived = true
        }
    }
    // check if sequenceOfTransfers (a required property) was received
    if !sequenceOfTransfersReceived {
        return errors.New("\"sequenceOfTransfers\" is required but was not present")
    }
    return nil
}

func (strct *SegmentErrorIndication) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "SegmentPositionInMessageBody" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "segmentPositionInMessageBody" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"segmentPositionInMessageBody\": ")
	if tmp, err := json.Marshal(strct.SegmentPositionInMessageBody); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "syntaxErrorCoded" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"syntaxErrorCoded\": ")
	if tmp, err := json.Marshal(strct.SyntaxErrorCoded); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SegmentErrorIndication) UnmarshalJSON(b []byte) error {
    segmentPositionInMessageBodyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "segmentPositionInMessageBody":
            if err := json.Unmarshal([]byte(v), &strct.SegmentPositionInMessageBody); err != nil {
                return err
             }
            segmentPositionInMessageBodyReceived = true
        case "syntaxErrorCoded":
            if err := json.Unmarshal([]byte(v), &strct.SyntaxErrorCoded); err != nil {
                return err
             }
        }
    }
    // check if segmentPositionInMessageBody (a required property) was received
    if !segmentPositionInMessageBodyReceived {
        return errors.New("\"segmentPositionInMessageBody\" is required but was not present")
    }
    return nil
}
